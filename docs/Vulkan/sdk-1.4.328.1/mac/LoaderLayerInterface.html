<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="icon" href="images/Vulkan_LogoBug_48px_Nov17.png">
<link rel="stylesheet" href="github-markdown.css">
</head>
<body>
<article class="markdown-body">
<!-- markdownlint-disable MD041 -->

<p><a href="https://www.khronos.org/vulkan/" TARGET="_blank"><img src="https://vulkan.lunarg.com/img/Vulkan_100px_Dec16.png" title="https://www.khronos.org/vulkan/" alt="Khronos Vulkan" /></a></p>
<h1 id="layer-interface-to-the-loader-">Layer Interface to the Loader <!-- omit from toc --></h1>
<p><a href="https://creativecommons.org/licenses/by-nd/4.0/" TARGET="_blank"><img src="https://i.creativecommons.org/l/by-nd/4.0/88x31.png" title="Creative Commons License" alt="Creative Commons" /></a></p>
<!-- Copyright &copy; 2015-2023 LunarG, Inc. -->

<h2 id="table-of-contents-">Table of Contents <!-- omit from toc --></h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#layer-discovery">Layer Discovery</a>
<ul>
<li><a href="#layer-manifest-file-usage">Layer Manifest File Usage</a></li>
<li><a href="#android-layer-discovery">Android Layer Discovery</a></li>
<li><a href="#windows-layer-discovery">Windows Layer Discovery</a></li>
<li><a href="#linux-layer-discovery">Linux Layer Discovery</a>
<ul>
<li><a href="#example-linux-explicit-layer-search-path">Example Linux Explicit Layer Search Path</a></li>
</ul></li>
<li><a href="#fuchsia-layer-discovery">Fuchsia Layer Discovery</a></li>
<li><a href="#macos-layer-discovery">macOS Layer Discovery</a>
<ul>
<li><a href="#example-macos-implicit-layer-search-path">Example macOS Implicit Layer Search Path</a></li>
</ul></li>
<li><a href="#layer-filtering">Layer Filtering</a>
<ul>
<li><a href="#layer-enable-filtering">Layer Enable Filtering</a></li>
<li><a href="#layer-disable-filtering">Layer Disable Filtering</a></li>
<li><a href="#layer-special-case-disable">Layer Special Case Disable</a></li>
<li><a href="#layer-disable-warning">Layer Disable Warning</a></li>
<li><a href="#allow-certain-layers-to-ignore-layer-disabling">Allow certain Layers to ignore Layer Disabling</a>
<ul>
<li><a href="#vk_instance_layers"><code>VK_INSTANCE_LAYERS</code></a></li>
</ul></li>
</ul></li>
<li><a href="#exception-for-elevated-privileges">Exception for Elevated Privileges</a></li>
</ul></li>
<li><a href="#layer-version-negotiation">Layer Version Negotiation</a></li>
<li><a href="#layer-call-chains-and-distributed-dispatch">Layer Call Chains and Distributed Dispatch</a></li>
<li><a href="#layer-unknown-physical-device-extensions">Layer Unknown Physical Device Extensions</a>
<ul>
<li><a href="#reason-for-adding-vk_layergetphysicaldeviceprocaddr">Reason for adding <code>vk_layerGetPhysicalDeviceProcAddr</code></a></li>
</ul></li>
<li><a href="#layer-intercept-requirements">Layer Intercept Requirements</a></li>
<li><a href="#distributed-dispatching-requirements">Distributed Dispatching Requirements</a></li>
<li><a href="#layer-conventions-and-rules">Layer Conventions and Rules</a></li>
<li><a href="#layer-dispatch-initialization">Layer Dispatch Initialization</a></li>
<li><a href="#example-code-for-createinstance">Example Code for CreateInstance</a></li>
<li><a href="#example-code-for-createdevice">Example Code for CreateDevice</a></li>
<li><a href="#meta-layers">Meta-layers</a>
<ul>
<li><a href="#override-meta-layer">Override Meta-Layer</a></li>
</ul></li>
<li><a href="#pre-instance-functions">Pre-Instance Functions</a></li>
<li><a href="#special-considerations">Special Considerations</a>
<ul>
<li><a href="#associating-private-data-with-vulkan-objects-within-a-layer">Associating Private Data with Vulkan Objects Within a Layer</a>
<ul>
<li><a href="#wrapping">Wrapping</a></li>
<li><a href="#cautions-about-wrapping">Cautions About Wrapping</a></li>
<li><a href="#hash-maps">Hash Maps</a></li>
</ul></li>
<li><a href="#creating-new-dispatchable-objects">Creating New Dispatchable Objects</a></li>
<li><a href="#versioning-and-activation-interactions">Versioning and Activation Interactions</a></li>
</ul></li>
<li><a href="#layer-manifest-file-format">Layer Manifest File Format</a>
<ul>
<li><a href="#layer-manifest-file-version-history">Layer Manifest File Version History</a></li>
<li><a href="#layer-manifest-file-version-121">Layer Manifest File Version 1.2.1</a>
<ul>
<li><a href="#layer-manifest-file-version-120">Layer Manifest File Version 1.2.0</a></li>
<li><a href="#layer-manifest-file-version-112">Layer Manifest File Version 1.1.2</a></li>
<li><a href="#layer-manifest-file-version-111">Layer Manifest File Version 1.1.1</a></li>
<li><a href="#layer-manifest-file-version-110">Layer Manifest File Version 1.1.0</a></li>
<li><a href="#layer-manifest-file-version-101">Layer Manifest File Version 1.0.1</a></li>
<li><a href="#layer-manifest-file-version-100">Layer Manifest File Version 1.0.0</a></li>
</ul></li>
</ul></li>
<li><a href="#layer-interface-versions">Layer Interface Versions</a>
<ul>
<li><a href="#layer-interface-version-2">Layer Interface Version 2</a></li>
<li><a href="#layer-interface-version-1">Layer Interface Version 1</a></li>
<li><a href="#layer-interface-version-0">Layer Interface Version 0</a></li>
</ul></li>
<li><a href="#loader-and-layer-interface-policy">Loader and Layer Interface Policy</a>
<ul>
<li><a href="#number-format">Number Format</a></li>
<li><a href="#android-differences">Android Differences</a></li>
<li><a href="#requirements-of-well-behaved-layers">Requirements of Well-Behaved Layers</a></li>
<li><a href="#requirements-of-a-well-behaved-loader">Requirements of a Well-Behaved Loader</a></li>
</ul></li>
</ul>
<h2 id="overview">Overview</h2>
<p>This is the Layer-centric view of working with the Vulkan loader. For the complete overview of all sections of the loader, please refer to the <a href="LoaderInterfaceArchitecture.html">LoaderInterfaceArchitecture.html</a> file.</p>
<h2 id="layer-discovery">Layer Discovery</h2>
<p>As mentioned in the <a href="LoaderApplicationInterface.html#implicit-vs-explicit-layers">Implicit versus Explicit</a>, section of the <a href="LoaderApplicationInterface.html">LoaderApplicationInterface.html</a> document, layers can be categorized into two categories:</p>
<ul>
<li>Implicit Layers</li>
<li>Explicit Layers</li>
</ul>
<p>The main difference between the two is that implicit layers are automatically enabled, unless overridden, and explicit layers must be enabled. Remember, implicit layers are not present on all Operating Systems (like Android).</p>
<p>On any system, the loader looks in specific areas for information on the layers that it can load at a user's request. The process of finding the available layers on a system is known as Layer Discovery. During discovery, the loader determines what layers are available, the layer name, the layer version, and any extensions supported by the layer. This information is provided back to an application through <code>vkEnumerateInstanceLayerProperties</code>.</p>
<p>The group of layers available to the loader is known as the <code>Layer Library</code>. This section defines an extensible interface to discover what layers are contained in the <code>Layer Library</code>.</p>
<p>This section also specifies the minimal conventions and rules a layer must follow, especially with regards to interacting with the loader and other layers.</p>
<p>When searching for a layer, the loader will look through the <code>Layer Library</code> in the order it detected them and load the layer if the name matches. If multiple instances of the same library exist in different locations throughout the user's system, then the one appearing first in the search order will be used. Each OS has its own search order that is defined in its layer discovery section below. If multiple manifest files in the same directory define the same layer, but point to different library files, the order which the layers is loaded is <a href="https://www.ibm.com/support/pages/order-directory-contents-returned-calls-readdir" TARGET="_blank">random due to the behavior of readdir</a>.</p>
<p>Additionally, any duplicate layer names in either the component layer list, or globally among all enabled layers, during calls to <code>vkCreateInstance</code> or <code>vkCreateDevice</code> will simply be ignored by the loader. Only the first occurrence of any layer name will be used.</p>
<h3 id="layer-manifest-file-usage">Layer Manifest File Usage</h3>
<p>On Windows, Linux, and macOS systems, JSON-formatted manifest files are used to store layer information. In order to find system-installed layers, the Vulkan loader will read the JSON files to identify the names and attributes of layers and their extensions. The use of manifest files allows the loader to avoid loading any shared library files when the application does not query nor request any extensions. The format of <a href="#layer-manifest-file-format">Layer Manifest File</a> is detailed below.</p>
<p>The Android loader does not use manifest files. Instead, the loader queries the layer properties using special functions known as "introspection" functions. The intent of these functions is to determine the same required information gathered from reading the manifest files. These introspection functions are not used by the Khronos loader but should be present in layers to maintain consistency. The specific "introspection" functions are called out in the <a href="#layer-manifest-file-format">Layer Manifest File Format</a> table.</p>
<h3 id="android-layer-discovery">Android Layer Discovery</h3>
<p>On Android, the loader looks for layers to enumerate in the <code>/data/local/debug/vulkan</code> folder. An application enabled for debug has the ability to enumerate and enable any layers in that location.</p>
<h3 id="windows-layer-discovery">Windows Layer Discovery</h3>
<p>In order to find system-installed layers, the Vulkan loader will scan the values in the following Windows registry keys:</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan\ExplicitLayers
HKEY_CURRENT_USER\SOFTWARE\Khronos\Vulkan\ExplicitLayers
HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan\ImplicitLayers
HKEY_CURRENT_USER\SOFTWARE\Khronos\Vulkan\ImplicitLayers
</code></pre>
<p>Except when running a 32-bit application on 64-bit Windows, when the loader will instead scan the 32-bit registry location:</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Khronos\Vulkan\ExplicitLayers
HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\Khronos\Vulkan\ExplicitLayers
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Khronos\Vulkan\ImplicitLayers
HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\Khronos\Vulkan\ImplicitLayers
</code></pre>
<p>For each value in these keys which has DWORD data set to 0, the loader opens the JSON manifest file specified by the name of the value. Each name must be an absolute path to the manifest file. Additionally, the <code>HKEY_CURRENT_USER</code> locations will only be searched if an application is not being executed with administrative privileges. This is done to ensure that an application with administrative privileges does not run layers that did not need administrator access to install.</p>
<p>Because some layers are installed alongside drivers, the loader will scan through registry keys specific to Display Adapters and all Software Components associated with these adapters for the locations of JSON manifest files. These keys are located in device keys created during driver installation and contain configuration information for base settings, including Vulkan, OpenGL, and Direct3D ICD location.</p>
<p>The Device Adapter and Software Component key paths should be obtained through the PnP Configuration Manager API. The <code>000X</code> key will be a numbered key, where each device is assigned a different number.</p>
<pre><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Adapter GUID}\000X\VulkanExplicitLayers
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Adapter GUID}\000X\VulkanImplicitLayers
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Software Component GUID}\000X\VulkanExplicitLayers
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Software Component GUID}\000X\VulkanImplicitLayers
</code></pre>
<p>In addition, on 64-bit systems there may be another set of registry values, listed below. These values record the locations of 32-bit layers on 64-bit operating systems, in the same way as the Windows-on-Windows functionality.</p>
<pre><code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Adapter GUID}\000X\VulkanExplicitLayersWow
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Adapter GUID}\000X\VulkanImplicitLayersWow
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Software Component GUID}\000X\VulkanExplicitLayersWow
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Class\{Software Component GUID}\000X\VulkanImplicitLayersWow
</code></pre>
<p>If any of the above values exist and is of type <code>REG_SZ</code>, the loader will open the JSON manifest file specified by the key value. Each value must be an absolute path to a JSON manifest file. A key value may also be of type <code>REG_MULTI_SZ</code>, in which case the value will be interpreted as a list of paths to JSON manifest files.</p>
<p>In general, applications should install layers into the <code>SOFTWARE\Khronos\Vulkan</code> paths. The PnP registry locations are intended specifically for layers that are distributed as part of a driver installation. An application installer should not modify the device-specific registries, while a device driver should not modify the system registries.</p>
<p>Additionally, the Vulkan loader will scan the system for well-known Windows AppX/MSIX packages. If a package is found, the loader will scan the root directory of this installed package for JSON manifest files. At this time, the only package that is known is Microsoft's <a href="https://apps.microsoft.com/store/detail/9NQPSL29BFFF?hl=en-us&amp;gl=US" TARGET="_blank">OpenCL™, OpenGL®, and Vulkan® Compatibility Pack</a>.</p>
<p>The Vulkan loader will open each manifest file to obtain information about the layer, including the name or pathname of a shared library (".dll") file.</p>
<p>If <code>VK_LAYER_PATH</code> is defined, then the loader will look at the paths defined by that variable for explicit layer manifest files instead of using the information provided by the explicit layer registry keys.</p>
<p>If <code>VK_ADD_LAYER_PATH</code> is defined, then the loader will look at the provided paths for explicit layer manifest files in addition to using the information provided by the explicit layer registry keys. The paths provided by <code>VK_ADD_LAYER_PATH</code> are added before the standard list of search folders and will therefore be searched first.</p>
<p>If <code>VK_LAYER_PATH</code> is present, then <code>VK_ADD_LAYER_PATH</code> will not be used by the loader and any values will be ignored.</p>
<p>If <code>VK_IMPLICIT_LAYER_PATH</code> is defined, then the loader will look at the paths defined by that variable for implicit layer manifest files instead of using the information provided by the implicit layer registry keys.</p>
<p>If <code>VK_ADD_IMPLICIT_LAYER_PATH</code> is defined, then the loader will look at the provided paths for implicit layer manifest files in addition to using the information provided by the implicit layer registry keys. The paths provided by <code>VK_ADD_IMPLICIT_LAYER_PATH</code> are added before the standard list of search folders and will therefore be searched first.</p>
<p>For security reasons, <code>VK_LAYER_PATH</code>, <code>VK_ADD_LAYER_PATH</code>, <code>VK_IMPLICIT_LAYER_PATH</code>, and <code>VK_ADD_IMPLICIT_LAYER_PATH</code> are ignored if running with elevated privileges. See <a href="#exception-for-elevated-privileges">Exception for Elevated Privileges</a> for more info.</p>
<p>See <a href="LoaderApplicationInterface.html#forcing-layer-source-folders">Forcing Layer Source Folders</a> in the <a href="LoaderApplicationInterface.html">LoaderApplicationInterface.html document</a> for more information on this.</p>
<h3 id="linux-layer-discovery">Linux Layer Discovery</h3>
<p>On Linux, the Vulkan loader will scan for manifest files using environment variables or corresponding fallback values if the corresponding environment variable is not defined:</p>
<table style="width:100%">
  <tr>
    <th>Search Order</th>
    <th>Directory/Environment Variable</th>
    <th>Fallback</th>
    <th>Additional Notes</th>
  </tr>
  <tr>
    <td>1</td>
    <td>$XDG_CONFIG_HOME</td>
    <td>$HOME/.config</td>
    <td><b>This path is ignored when running with elevated privileges such as
           setuid, setgid, or filesystem capabilities</b>.<br/>
        This is done because under these scenarios it is not safe to trust
        that the environment variables are non-malicious.
    </td>
  </tr>
  <tr>
    <td>1</td>
    <td>$XDG_CONFIG_DIRS</td>
    <td>/etc/xdg</td>
    <td></td>
  </tr>
  <tr>
    <td>2</td>
    <td>SYSCONFDIR</td>
    <td>/etc</td>
    <td>Compile-time option set to possible location of layers installed from
        non-Linux-distribution-provided packages.
    </td>
  </tr>
  <tr>
    <td>3</td>
    <td>EXTRASYSCONFDIR</td>
    <td>/etc</td>
    <td>Compile-time option set to possible location of layers installed from
        non-Linux-distribution-provided packages.
        Typically only set if SYSCONFDIR is set to something other than /etc
    </td>
  </tr>
  <tr>
    <td>4</td>
    <td>$XDG_DATA_HOME</td>
    <td>$HOME/.local/share</td>
    <td><b>This path is ignored when running with elevated privileges such as
           setuid, setgid, or filesystem capabilities</b>.<br/>
        This is done because under these scenarios it is not safe to trust
        that the environment variables are non-malicious.
    </td>
  </tr>
  <tr>
    <td>5</td>
    <td>$XDG_DATA_DIRS</td>
    <td>/usr/local/share/:/usr/share/</td>
    <td></td>
  </tr>
</table>

<p>The directory lists are concatenated together using the standard platform path separator (:). The loader then selects each path, and applies a suffix onto it for the specific type of layer being searched for and looks in that specific folder for manifest files:</p>
<ul>
<li>Implicit Layers: Suffix = /vulkan/implicit_layer.d</li>
<li>Explicit Layers: Suffix = /vulkan/explicit_layer.d</li>
</ul>
<p>If <code>VK_LAYER_PATH</code> is defined, then the loader will look at the paths defined by that variable for explicit layer manifest files instead of using the information provided by the standard explicit layer paths mentioned above.</p>
<p>If <code>VK_ADD_LAYER_PATH</code> is defined, then the loader will look at the provided paths for explicit layer manifest files in addition to using the information provided by the standard explicit layer paths mentioned above. The paths provided by <code>VK_ADD_LAYER_PATH</code> are added before the standard list of search folders and will therefore be searched first.</p>
<p>If <code>VK_LAYER_PATH</code> is present, then <code>VK_ADD_LAYER_PATH</code> will not be used by the loader and any values will be ignored.</p>
<p>If <code>VK_IMPLICIT_LAYER_PATH</code> is defined, then the loader will look at the paths defined by that variable for implicit layer manifest files instead of using the information provided by the standard implicit layer paths mentioned above.</p>
<p>If <code>VK_ADD_IMPLICIT_LAYER_PATH</code> is defined, then the loader will look at the provided paths for implicit layer manifest files in addition to using the information provided by the standard implicit layer paths mentioned above. The paths provided by <code>VK_ADD_IMPLICIT_LAYER_PATH</code> are added before the standard list of search folders and will therefore be searched first.</p>
<p>If <code>VK_IMPLICIT_LAYER_PATH</code> is present, then <code>VK_ADD_IMPLICIT_LAYER_PATH</code> will not be used by the loader and any values will be ignored.</p>
<p>For security reasons, <code>VK_LAYER_PATH</code>, <code>VK_ADD_LAYER_PATH</code>, <code>VK_IMPLICIT_LAYER_PATH</code>, and <code>VK_ADD_IMPLICIT_LAYER_PATH</code> are ignored if running with elevated privileges. See <a href="#exception-for-elevated-privileges">Exception for Elevated Privileges</a> for more info.</p>
<p><strong>NOTE</strong> While the order of folders searched for manifest files is well defined, the order contents are read by the loader in each directory is <a href="https://www.ibm.com/support/pages/order-directory-contents-returned-calls-readdir" TARGET="_blank">random due to the behavior of readdir</a>.</p>
<p>See <a href="LoaderApplicationInterface.html#forcing-layer-source-folders">Forcing Layer Source Folders</a> in the <a href="LoaderApplicationInterface.html">LoaderApplicationInterface.html document</a> for more information on this.</p>
<p>It is also important to note that while <code>VK_LAYER_PATH</code>, <code>VK_ADD_LAYER_PATH</code>, <code>VK_IMPLICIT_LAYER_PATH</code>, and <code>VK_ADD_IMPLICIT_LAYER_PATH</code> will point the loader at paths to search for finding the manifest files, it does not guarantee the library files mentioned by the manifest will immediately be found. Often, the layer manifest file will point to the library file using a relative or absolute path. When a relative or absolute path is used, the loader can typically find the library file without querying the operating system. However, if a library is listed only by name, the loader may not find it. If problems occur finding a library file associated with a layer, try updating the <code>LD_LIBRARY_PATH</code> environment variable to point at the location of the corresponding <code>.so</code> file.</p>
<h4 id="example-linux-explicit-layer-search-path">Example Linux Explicit Layer Search Path</h4>
<p>For a fictional user "me" the layer manifest search path might look like the following:</p>
<pre><code>  /home/me/.config/vulkan/explicit_layer.d
  /etc/xdg/vulkan/explicit_layer.d
  /usr/local/etc/vulkan/explicit_layer.d
  /etc/vulkan/explicit_layer.d
  /home/me/.local/share/vulkan/explicit_layer.d
  /usr/local/share/vulkan/explicit_layer.d
  /usr/share/vulkan/explicit_layer.d
</code></pre>
<h3 id="fuchsia-layer-discovery">Fuchsia Layer Discovery</h3>
<p>On Fuchsia, the Vulkan loader will scan for manifest files using environment variables or corresponding fallback values if the corresponding environment variable is not defined in the same way as <a href="#linux-layer-discovery">Linux</a>. The <strong>only</strong> difference is that Fuchsia does not allow fallback values for <em>$XDG_DATA_DIRS</em> or <em>$XDG_HOME_DIRS</em>.</p>
<h3 id="macos-layer-discovery">macOS Layer Discovery</h3>
<p>On macOS, the Vulkan loader will scan for manifest files using the application resource folder as well as environment variables or corresponding fallback values if the corresponding environment variable is not defined. The order is similar to the search path on Linux with the exception that the application's bundle resources are searched first: <code>(bundle)/Contents/Resources/</code>.</p>
<h4 id="example-macos-implicit-layer-search-path">Example macOS Implicit Layer Search Path</h4>
<p>For a fictional user "Me" the layer manifest search path might look like the following:</p>
<pre><code>  &lt;bundle&gt;/Contents/Resources/vulkan/implicit_layer.d
  /Users/Me/.config/vulkan/implicit_layer.d
  /etc/xdg/vulkan/implicit_layer.d
  /usr/local/etc/vulkan/implicit_layer.d
  /etc/vulkan/implicit_layer.d
  /Users/Me/.local/share/vulkan/implicit_layer.d
  /usr/local/share/vulkan/implicit_layer.d
  /usr/share/vulkan/implicit_layer.d
</code></pre>
<h3 id="layer-filtering">Layer Filtering</h3>
<p><strong>NOTE:</strong> This functionality is only available with Loaders built with version 1.3.234 of the Vulkan headers and later.</p>
<p>The loader supports filter environment variables which can forcibly enable and disable known layers. Known layers are those that are already found by the loader taking into account default search paths and environment variables <code>VK_LAYER_PATH</code>, <code>VK_ADD_LAYER_PATH</code>, <code>VK_IMPLICIT_LAYER_PATH</code>, and <code>VK_ADD_IMPLICIT_LAYER_PATH</code>.</p>
<p>The filter variables will be compared against the layer name provided in the layer's manifest file.</p>
<p>The filters must also follow the behaviors define in the <a href="LoaderInterfaceArchitecture.html#filter-environment-variable-behaviors">Filter Environment Variable Behaviors</a> section of the <a href="LoaderLayerInterface.html">LoaderLayerInterface</a> document.</p>
<h4 id="layer-enable-filtering">Layer Enable Filtering</h4>
<p>The layer enable environment variable <code>VK_LOADER_LAYERS_ENABLE</code> is a comma-delimited list of globs to search for in known layers. The layer names are compared against the globs listed in the environment variable, and if they match, they will automatically be added to the enabled layer list in the loader for each application. These layers are enabled after implicit layers but before other explicit layers.</p>
<p>When a layer is enabled using the <code>VK_LOADER_LAYERS_ENABLE</code> filter, and loader logging is set to emit either warnings or layer messages, then a message will show for each layer that has been forced on. This message will look like the following:</p>
<pre><code>[Vulkan Loader] WARNING | LAYER:  Layer &quot;VK_LAYER_LUNARG_wrap_objects&quot; force enabled due to env var &#39;VK_LOADER_LAYERS_ENABLE&#39;
</code></pre>
<h4 id="layer-disable-filtering">Layer Disable Filtering</h4>
<p>The layer disable environment variable <code>VK_LOADER_LAYERS_DISABLE</code> is a comma-delimited list of globs to search for in known layers. The layer names are compared against the globs listed in the environment variable, and if they match, they will automatically be disabled (whether or not the layer is Implicit or Explicit). This means that they will not be added to the enabled layer list in the loader for each application. This could mean that layers requested by an application are also not enabled such as <code>VK_KHRONOS_LAYER_synchronization2</code> which could cause some applications to misbehave.</p>
<p>When a layer is disabled using the <code>VK_LOADER_LAYERS_DISABLE</code> filter, and loader logging is set to emit either warnings or layer messages, then a message will show for each layer that has been forcibly disabled. This message will look like the following:</p>
<pre><code>[Vulkan Loader] WARNING | LAYER:  Layer &quot;VK_LAYER_LUNARG_wrap_objects&quot; disabled because name matches filter of env var &#39;VK_LOADER_LAYERS_DISABLE&#39;
</code></pre>
<h4 id="layer-special-case-disable">Layer Special Case Disable</h4>
<p>Because there are different types of layers, there are 3 additional special disable options available when using the <code>VK_LOADER_LAYERS_DISABLE</code> environment variable.</p>
<p>These are:</p>
<ul>
<li><code>~all~</code></li>
<li><code>~implicit~</code></li>
<li><code>~explicit~</code></li>
</ul>
<p><code>~all~</code> will effectively disable every layer. This enables a developer to disable all layers on the system. <code>~implicit~</code> will effectively disable every implicit layer (leaving explicit layers still present in the application call chain). <code>~explicit~</code> will effectively disable every explicit layer (leaving implicit layers still present in the application call chain).</p>
<h4 id="layer-disable-warning">Layer Disable Warning</h4>
<p>Disabling layers, whether just through normal usage of <code>VK_LOADER_LAYERS_DISABLE</code> or by evoking one of the special disable options like <code>~all~</code> or <code>~explicit~</code> could cause application breakage if the application is relying on features provided by one or more explicit layers.</p>
<h4 id="allow-certain-layers-to-ignore-layer-disabling">Allow certain Layers to ignore Layer Disabling</h4>
<p><strong>NOTE:</strong> VK_LOADER_LAYERS_DISABLE is only available with Loaders built with version 1.3.262 of the Vulkan headers and later.</p>
<p>The layer allow environment variable <code>VK_LOADER_LAYERS_ALLOW</code> is a comma-delimited list of globs to search for in known layers. The layer names are compared against the globs listed in the environment variable, and if they match, they will not be able to be disabled by <code>VK_LOADER_LAYERS_DISABLE</code>.</p>
<p>Implicit layers have the ability to only be enabled when a layer specified environment variable is set, allow for context dependent enablement. <code>VK_LOADER_LAYERS_ENABLE</code> ignores that context. <code>VK_LOADER_LAYERS_ALLOW</code> behaves similar to <code>VK_LOADER_LAYERS_ENABLE</code> while also respecting the context which is normally used to determine whether an implicit layer should be enabled.</p>
<p><code>VK_LOADER_LAYERS_ALLOW</code> effectively negates the behavior of <code>VK_LOADER_LAYERS_DISABLE</code>. Explicit layers listed by <code>VK_LOADER_LAYERS_ALLOW</code> will not be enabled. Implicit layers listed by ``VK_LOADER_LAYERS_ALLOW` which are always active, i.e. they do not require any external context to be enabled, will be enabled.</p>
<h5 id="vk_instance_layers"><code>VK_INSTANCE_LAYERS</code></h5>
<p>The original <code>VK_INSTANCE_LAYERS</code> can be viewed as a special case of <code>VK_LOADER_LAYERS_ENABLE</code>. Because of this, any layers enabled via <code>VK_INSTANCE_LAYERS</code> will be treated the same as layers enabled with <code>VK_LOADER_LAYERS_ENABLE</code> and will therefore override any disables supplied in <code>VK_LOADER_LAYERS_DISABLE</code>.</p>
<h3 id="exception-for-elevated-privileges">Exception for Elevated Privileges</h3>
<p>For security reasons, <code>VK_LAYER_PATH</code>, <code>VK_ADD_LAYER_PATH</code>, <code>VK_IMPLICIT_LAYER_PATH</code> and <code>VK_ADD_IMPLICIT_LAYER_PATH</code> are ignored if running the Vulkan application with elevated privileges. This is because they may insert new libraries into the executable process that are not normally found by the loader. Because of this, these environment variables can only be used for applications that do not use elevated privileges.</p>
<p>For more information see <a href="LoaderInterfaceArchitecture.html#elevated-privilege-caveats">Elevated Privilege Caveats</a> in the top-level [LoaderInterfaceArchitecture.html][LoaderInterfaceArchitecture.html] document.</p>
<h2 id="layer-version-negotiation">Layer Version Negotiation</h2>
<p>Now that a layer has been discovered, an application can choose to load it, or in the case of implicit layers, it can be loaded by default. When the loader attempts to load the layer, the first thing it does is attempt to negotiate the version of the loader to layer interface. In order to negotiate the loader/layer interface version, the layer must implement the <code>vkNegotiateLoaderLayerInterfaceVersion</code> function. The following information is provided for this interface in include/vulkan/vk_layer.h:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">typedef</span> <span class="kw">enum</span> VkNegotiateLayerStructType {</a>
<a class="sourceLine" id="cb9-2" title="2">    LAYER_NEGOTIATE_INTERFACE_STRUCT = <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb9-3" title="3">} VkNegotiateLayerStructType;</a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">typedef</span> <span class="kw">struct</span> VkNegotiateLayerInterface {</a>
<a class="sourceLine" id="cb9-6" title="6">    VkNegotiateLayerStructType sType;</a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="dt">void</span> *pNext;</a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="dt">uint32_t</span> loaderLayerInterfaceVersion;</a>
<a class="sourceLine" id="cb9-9" title="9">    PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;</a>
<a class="sourceLine" id="cb9-10" title="10">    PFN_vkGetDeviceProcAddr pfnGetDeviceProcAddr;</a>
<a class="sourceLine" id="cb9-11" title="11">    PFN_GetPhysicalDeviceProcAddr pfnGetPhysicalDeviceProcAddr;</a>
<a class="sourceLine" id="cb9-12" title="12">} VkNegotiateLayerInterface;</a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14">VkResult</a>
<a class="sourceLine" id="cb9-15" title="15">   vkNegotiateLoaderLayerInterfaceVersion(</a>
<a class="sourceLine" id="cb9-16" title="16">      VkNegotiateLayerInterface *pVersionStruct);</a></code></pre></div>
<p>The <code>VkNegotiateLayerInterface</code> structure is similar to other Vulkan structures. The "sType" field, in this case takes a new enum defined just for internal loader/layer interfacing use. The valid values for "sType" could grow in the future, but right now only has the one value "LAYER_NEGOTIATE_INTERFACE_STRUCT".</p>
<p>This function (<code>vkNegotiateLoaderLayerInterfaceVersion</code>) should be exported by the layer so that using "GetProcAddress" on Windows or "dlsym" on Linux or macOS, should return a valid function pointer to it. Once the loader has grabbed a valid address to the layers function, the loader will create a variable of type <code>VkNegotiateLayerInterface</code> and initialize it in the following ways:</p>
<ol>
<li>Set the structure "sType" to "LAYER_NEGOTIATE_INTERFACE_STRUCT"</li>
<li>Set pNext to NULL.
<ul>
<li>This is for future growth</li>
</ul></li>
<li>Set "loaderLayerInterfaceVersion" to the current version the loader desires to set the interface to.
<ul>
<li>The minimum value sent by the loader will be 2 since it is the first version supporting this function.</li>
</ul></li>
</ol>
<p>The loader will then individually call each layer’s <code>vkNegotiateLoaderLayerInterfaceVersion</code> function with the filled out “VkNegotiateLayerInterface”.</p>
<p>This function allows the loader and layer to agree on an interface version to use. The "loaderLayerInterfaceVersion" field is both an input and output parameter. "loaderLayerInterfaceVersion" is filled in by the loader with the desired latest interface version supported by the loader (typically the latest). The layer receives this and returns back the version it desires in the same field. Because it is setting up the interface version between the loader and layer, this should be the first call made by a loader to the layer (even prior to any calls to <code>vkGetInstanceProcAddr</code>).</p>
<p>If the layer receiving the call no longer supports the interface version provided by the loader (due to deprecation), then it should report a <code>VK_ERROR_INITIALIZATION_FAILED</code> error. Otherwise it sets the value pointed by "loaderLayerInterfaceVersion" to the latest interface version supported by both the layer and the loader and returns <code>VK_SUCCESS</code>.</p>
<p>The layer should report <code>VK_SUCCESS</code> in case the loader-provided interface version is newer than that supported by the layer, as it's the loader's responsibility to determine whether it can support the older interface version supported by the layer. The layer should also report <code>VK_SUCCESS</code> in the case its interface version is greater than the loader's, but return the loader's version. Thus, upon return of <code>VK_SUCCESS</code> the "loaderLayerInterfaceVersion" will contain the desired interface version to be used by the layer.</p>
<p>If the loader receives <code>VK_ERROR_INITIALIZATION_FAILED</code> instead of <code>VK_SUCCESS</code>, then the loader will treat the layer as unusable and will not load it. In this case, the application will not see the layer during enumeration. <em>Note that the loader is currently backwards compatible with all layer interface versions, so a layer should not be able to request a version older than what the loader supports.</em></p>
<p>This function <strong>MUST NOT</strong> call down the layer chain to the next layer. The loader will work with each layer individually.</p>
<p>If the layer supports the new interface and reports version 2 or greater, then The layer should fill in the function pointer values to its internal functions: - "pfnGetInstanceProcAddr" should be set to the layer’s internal <code>GetInstanceProcAddr</code> function. - "pfnGetDeviceProcAddr" should be set to the layer’s internal <code>GetDeviceProcAddr</code> function. - "pfnGetPhysicalDeviceProcAddr" should be set to the layer’s internal <code>GetPhysicalDeviceProcAddr</code> function. - If the layer supports no physical device extensions, it may set the value to NULL. - More on this function later the loader will use the “fpGetInstanceProcAddr” and “fpGetDeviceProcAddr” functions from the “VkNegotiateLayerInterface” structure. Prior to these changes, the loader would query each of those functions using "GetProcAddress" on Windows or "dlsym" on Linux or macOS.</p>
<h2 id="layer-call-chains-and-distributed-dispatch">Layer Call Chains and Distributed Dispatch</h2>
<p>There are two key architectural features that drive the loader to <code>Layer Library</code> interface:</p>
<ol>
<li>Separate and distinct instance and device call chains</li>
<li>Distributed dispatch.</li>
</ol>
<p>For further information, read the overview of dispatch tables and call chains above in the <a href="LoaderInterfaceArchitecture.html#dispatch-tables-and-call-chains">Dispatch Tables and Call Chains</a> section of the <a href="LoaderInterfaceArchitecture.html">LoaderInterfaceArchitecture.html document</a>.</p>
<p>What's important to note here is that a layer can intercept Vulkan instance functions, device functions or both. For a layer to intercept instance functions, it must participate in the instance call chain. For a layer to intercept device functions, it must participate in the device call chain.</p>
<p>Remember, a layer does not need to intercept all instance or device functions, instead, it can choose to intercept only a subset of those functions.</p>
<p>Normally, when a layer intercepts a given Vulkan function, it will call down the instance or device call chain as needed. The loader and all layer libraries that participate in a call chain cooperate to ensure the correct sequencing of calls from one entity to the next. This group effort for call chain sequencing is hereinafter referred to as <strong>distributed dispatch</strong>.</p>
<p>In distributed dispatch each layer is responsible for properly calling the next entity in the call chain. This means that a dispatch mechanism is required for all Vulkan functions that a layer intercepts. If a Vulkan function is not intercepted by a layer, or if a layer chooses to terminate the function by not calling down the chain, then no dispatch is needed for that particular function.</p>
<p>For example, if the enabled layers intercepted only certain instance functions, the call chain would look as follows: <img src="./images/function_instance_chain.png" alt="Instance Function Chain" /></p>
<p>Likewise, if the enabled layers intercepted only a few of the device functions, the call chain could look this way: <img src="./images/function_device_chain.png" alt="Device Function Chain" /></p>
<p>The loader is responsible for dispatching all core and instance extension Vulkan functions to the first entity in the call chain.</p>
<h2 id="layer-unknown-physical-device-extensions">Layer Unknown Physical Device Extensions</h2>
<p>Layers that intercept entrypoints which take a <code>VkPhysicalDevice</code> as the first parameter <em>should</em> support <code>vk_layerGetPhysicalDeviceProcAddr</code>. This function is added to the Layer Interface Version 2 and allows the loader to distinguish between entrypoints which take <code>VkDevice</code> and <code>VkPhysicalDevice</code> as the first parameter. This allows the loader to properly support entrypoints that are unknown to it gracefully.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1">PFN_vkVoidFunction</a>
<a class="sourceLine" id="cb10-2" title="2">   vk_layerGetPhysicalDeviceProcAddr(</a>
<a class="sourceLine" id="cb10-3" title="3">      VkInstance instance,</a>
<a class="sourceLine" id="cb10-4" title="4">      <span class="at">const</span> <span class="dt">char</span>* pName);</a></code></pre></div>
<p>This function behaves similar to <code>vkGetInstanceProcAddr</code> and <code>vkGetDeviceProcAddr</code> except it should only return values for physical device extension entry-points. In this way, it compares "pName" to every physical device function supported in the layer.</p>
<p>Implementations of the function should have the following behavior:</p>
<ul>
<li>If it is the name of a physical device function supported by the layer, the pointer to the layer's corresponding function should be returned.</li>
<li>If it is the name of a valid function which is <strong>not</strong> a physical device function (i.e. an instance, device, or other function implemented by the layer), then the value of NULL should be returned.
<ul>
<li>The layer doesn't call down since the command is not a physical device extension.</li>
</ul></li>
<li>If the layer has no idea what this function is, it should call down the layer chain to the next <code>vk_layerGetPhysicalDeviceProcAddr</code> call.
<ul>
<li>This can be retrieved in one of two ways:
<ul>
<li>During <code>vkCreateInstance</code>, it is passed to a layer in the chain information passed to a layer in the <code>VkLayerInstanceCreateInfo</code> structure.
<ul>
<li>Use <code>get_chain_info()</code> to get the pointer to the <code>VkLayerInstanceCreateInfo</code> structure. Let's call it chain_info.</li>
<li>The address is then under chain_info-&gt;u.pLayerInfo-&gt;pfnNextGetPhysicalDeviceProcAddr</li>
<li>See <a href="#example-code-for-createinstance">Example Code for CreateInstance</a></li>
</ul></li>
<li>Using the next layer’s <code>GetInstanceProcAddr</code> function to query for <code>vk_layerGetPhysicalDeviceProcAddr</code>.</li>
</ul></li>
</ul></li>
</ul>
<p>If a layer intends to support functions that take VkPhysicalDevice as the dispatchable parameter, then layer should support <code>vk_layerGetPhysicalDeviceProcAddr</code>. This is because if these functions aren't known to the loader, such as those from unreleased extensions or because the loader is an older build thus doesn't know about them <em>yet</em>, the loader won't be able to distinguish whether this is a device or physical device function.</p>
<p>If a layer does implement <code>vk_layerGetPhysicalDeviceProcAddr</code>, it should return the address of its <code>vk_layerGetPhysicalDeviceProcAddr</code> function in the "pfnGetPhysicalDeviceProcAddr" member of the <code>VkNegotiateLayerInterface</code> structure during <a href="#layer-version-negotiation">Layer Version Negotiation</a>. Additionally, the layer should also make sure <code>vkGetInstanceProcAddr</code> returns a valid function pointer to a query of <code>vk_layerGetPhysicalDeviceProcAddr</code>.</p>
<p>Note: If a layer wraps the VkInstance handle, support for <code>vk_layerGetPhysicalDeviceProcAddr</code> is <em>NOT</em> optional and must be implemented.</p>
<p>The behavior of the loader's <code>vkGetInstanceProcAddr</code> with support for the <code>vk_layerGetPhysicalDeviceProcAddr</code> function is as follows:</p>
<ol>
<li>Check if core function:
<ul>
<li>If it is, return the function pointer</li>
</ul></li>
<li>Check if known instance or device extension function:
<ul>
<li>If it is, return the function pointer</li>
</ul></li>
<li>Call the layer/driver <code>GetPhysicalDeviceProcAddr</code>
<ul>
<li>If it returns non-NULL, return a trampoline to a generic physical device function, and set up a generic terminator which will pass it to the proper driver.</li>
</ul></li>
<li>Call down using <code>GetInstanceProcAddr</code>
<ul>
<li>If it returns non-NULL, treat it as an unknown logical device command. This means setting up a generic trampoline function that takes in a <code>VkDevice</code> as the first parameter and adjusting the dispatch table to call the driver/layer's function after getting the dispatch table from the <code>VkDevice</code>. Then, return the pointer to corresponding trampoline function.</li>
</ul></li>
<li>Return NULL</li>
</ol>
<p>Then, if the command gets promoted to core later, it will no longer be set up using <code>vk_layerGetPhysicalDeviceProcAddr</code>. Additionally, if the loader adds direct support for the extension, it will no longer get to step 3, because step 2 will return a valid function pointer. However, the layer should continue to support the command query via <code>vk_layerGetPhysicalDeviceProcAddr</code>, until at least a Vulkan version bump, because an older loader may still be attempting to use the commands.</p>
<h3 id="reason-for-adding-vk_layergetphysicaldeviceprocaddr">Reason for adding <code>vk_layerGetPhysicalDeviceProcAddr</code></h3>
<p>Originally, if <code>vkGetInstanceProcAddr</code> was called in the loader, it would result in the following behavior:</p>
<ol>
<li>The loader would check if core function:
<ul>
<li>If it was, it would return the function pointer</li>
</ul></li>
<li>The loader would check if known extension function:
<ul>
<li>If it was, it would return the function pointer</li>
</ul></li>
<li>If the loader knew nothing about it, it would call down using <code>GetInstanceProcAddr</code>
<ul>
<li>If it returned non-NULL, treat it as an unknown logical device command.</li>
<li>This meant setting up a generic trampoline function that takes in a VkDevice as the first parameter and adjusting the dispatch table to call the Driver/Layer's function after getting the dispatch table from the <code>VkDevice</code>.</li>
</ul></li>
<li>If all the above failed, the loader would return NULL to the application.</li>
</ol>
<p>This caused problems when a layer attempted to expose new physical device extensions the loader knew nothing about, but an application did. Because the loader knew nothing about it, the loader would get to step 3 in the above process and would treat the function as an unknown logical device command. The problem is, this would create a generic VkDevice trampoline function which, on the first call, would attempt to dereference the VkPhysicalDevice as a VkDevice. This would lead to a crash or corruption.</p>
<h2 id="layer-intercept-requirements">Layer Intercept Requirements</h2>
<ul>
<li>Layers intercept a Vulkan function by defining a C/C++ function with signature <strong>identical</strong> to the Vulkan API for that function.</li>
<li>A layer <strong>must intercept at least</strong> <code>vkGetInstanceProcAddr</code> and <code>vkCreateInstance</code> to participate in the instance call chain.</li>
<li>A layer <strong>may also intercept</strong> <code>vkGetDeviceProcAddr</code> and <code>vkCreateDevice</code> to participate in the device call chain.</li>
<li>For any Vulkan function a layer intercepts which has a non-void return value, <strong>an appropriate value must be returned</strong> by the layer intercept function.</li>
<li>Most functions a layer intercepts <strong>should call down the chain</strong> to the corresponding Vulkan function in the next entity.
<ul>
<li>The common behavior for a layer is to intercept a call, perform some behavior, then pass it down to the next entity.
<ul>
<li>If a layer doesn't pass the information down, undefined behavior may occur.</li>
<li>This is because the function will not be received by layers further down the chain, or any drivers.</li>
</ul></li>
<li>One function that <strong>must never call down the chain</strong> is:
<ul>
<li><code>vkNegotiateLoaderLayerInterfaceVersion</code></li>
</ul></li>
<li>Three common functions that <strong>may not call down the chain</strong> are:
<ul>
<li><code>vkGetInstanceProcAddr</code></li>
<li><code>vkGetDeviceProcAddr</code></li>
<li><code>vk_layerGetPhysicalDeviceProcAddr</code></li>
<li>These functions only call down the chain for Vulkan functions that they do not intercept.</li>
</ul></li>
</ul></li>
<li>Layer intercept functions <strong>may insert extra calls</strong> to Vulkan functions in addition to the intercept.
<ul>
<li>For example, a layer intercepting <code>vkQueueSubmit</code> may want to add a call to <code>vkQueueWaitIdle</code> after calling down the chain for <code>vkQueueSubmit</code>.</li>
<li>This would result in two calls down the chain: First a call down the <code>vkQueueSubmit</code> chain, followed by a call down the <code>vkQueueWaitIdle</code> chain.</li>
<li>Any additional calls inserted by a layer must be on the same chain
<ul>
<li>If the function is a device function, only other device functions should be added.</li>
<li>Likewise, if the function is an instance function, only other instance functions should be added.</li>
</ul></li>
</ul></li>
</ul>
<h2 id="distributed-dispatching-requirements">Distributed Dispatching Requirements</h2>
<ul>
<li>For each entry-point a layer intercepts, it must keep track of the entry-point residing in the next entity in the chain it will call down into.
<ul>
<li>In other words, the layer must have a list of pointers to functions of the appropriate type to call into the next entity.</li>
<li>This can be implemented in various ways but for clarity, will be referred to as a dispatch table.</li>
</ul></li>
<li>A layer can use the <code>VkLayerDispatchTable</code> structure as a device dispatch table (see include/vulkan/vk_dispatch_table_helper.h).</li>
<li>A layer can use the <code>VkLayerInstanceDispatchTable</code> structure as a instance dispatch table (see include/vulkan/vk_dispatch_table_helper.h).</li>
<li>A Layer's <code>vkGetInstanceProcAddr</code> function uses the next entity's <code>vkGetInstanceProcAddr</code> to call down the chain for unknown (i.e. non-intercepted) functions.</li>
<li>A Layer's <code>vkGetDeviceProcAddr</code> function uses the next entity's <code>vkGetDeviceProcAddr</code> to call down the chain for unknown (i.e. non-intercepted) functions.</li>
<li>A Layer's <code>vk_layerGetPhysicalDeviceProcAddr</code> function uses the next entity's <code>vk_layerGetPhysicalDeviceProcAddr</code> to call down the chain for unknown (i.e. non-intercepted) functions.</li>
</ul>
<h2 id="layer-conventions-and-rules">Layer Conventions and Rules</h2>
<p>A layer, when inserted into an otherwise compliant Vulkan driver, <b>must</b> still result in a compliant Vulkan driver. The intention is for layers to have a well-defined baseline behavior. Therefore, it must follow some conventions and rules defined below.</p>
<p>In order for layers to have unique names, and reduce the chance of conflicts that could occur when the loader attempts to load these layers, layers <b>must</b> adhere to the following naming standard:</p>
<ul>
<li>Start with <code>VK_LAYER_</code> prefix</li>
<li>Follow the prefix with either an organization or company name (LunarG), a unique company identifier (NV for Nvidia) or a software product name (RenderDoc) in ALL CAPS</li>
<li>Follow that with the specific name of the layer (typically lower-case but not required to be)
<ul>
<li>NOTE: The specific name, if more than one word, <b>must</b> be underscore delimited</li>
</ul></li>
</ul>
<p>Examples of valid layer names include:</p>
<ul>
<li><b>VK_LAYER_KHRONOS_validation</b>
<ul>
<li>Organization = "KHRONOS"</li>
<li>Specific name = "validation"</li>
</ul></li>
<li><b>VK_LAYER_RENDERDOC_Capture</b>
<ul>
<li>Application = "RENDERDOC"</li>
<li>Specific name = "Capture"</li>
</ul></li>
<li><b>VK_LAYER_VALVE_steam_fossilize_32</b>
<ul>
<li>Organization = "VALVE"</li>
<li>Application = "steam"</li>
<li>Specific name = "fossilize"</li>
<li>OS-modifier = "32" (for 32-bit version)</li>
</ul></li>
<li><b>VK_LAYER_NV_nsight</b>
<ul>
<li>Organization Acronym = "NV" (for Nvidia)</li>
<li>Specific name = "nsight"</li>
</ul></li>
</ul>
<p>More details on layer naming can be found in the <a href="https://www.khronos.org/registry/vulkan/specs/1.2/styleguide.html#extensions-naming-conventions" TARGET="_blank">Vulkan style-guide</a> under section 3.4 "Version, Extension, and Layer Naming Conventions".</p>
<p>A layer is always chained with other layers. It must not make invalid calls to, or rely on undefined behaviors of, its lower layers. When it changes the behavior of a function, it must make sure its upper layers do not make invalid calls to or rely on undefined behaviors of its lower layers because of the changed behavior. For example, when a layer intercepts an object creation function to wrap the objects created by its lower layers, it must make sure its lower layers never see the wrapping objects, directly from itself or indirectly from its upper layers.</p>
<p>When a layer requires host memory, it may ignore the provided allocators. It is preferred that the layer use any provided memory allocators if the layer is intended to run in a production environment. For example, this usually applies to implicit layers that are always enabled. That will allow applications to include the layer's memory usage.</p>
<p>Additional rules include:</p>
<ul>
<li><code>vkEnumerateInstanceLayerProperties</code> <strong>must</strong> enumerate and <strong>only</strong> enumerate the layer itself.</li>
<li><code>vkEnumerateInstanceExtensionProperties</code> <strong>must</strong> handle the case where <code>pLayerName</code> is itself.
<ul>
<li>It <strong>must</strong> return <code>VK_ERROR_LAYER_NOT_PRESENT</code> otherwise, including when <code>pLayerName</code> is <code>NULL</code>.</li>
</ul></li>
<li><code>vkEnumerateDeviceLayerProperties</code> <strong>is deprecated and may be omitted</strong>.
<ul>
<li>Using this will result in undefined behavior.</li>
</ul></li>
<li><code>vkEnumerateDeviceExtensionProperties</code> <strong>must</strong> handle the case where <code>pLayerName</code> is itself.
<ul>
<li>In other cases, it should chain to other layers.</li>
</ul></li>
<li><code>vkCreateInstance</code> <strong>must not</strong> generate an error for unrecognized layer names and extension names.
<ul>
<li>It may assume the layer names and extension names have been validated.</li>
</ul></li>
<li><code>vkGetInstanceProcAddr</code> intercepts a Vulkan function by returning a local entry-point
<ul>
<li>Otherwise it returns the value obtained by calling down the instance call chain.</li>
</ul></li>
<li><code>vkGetDeviceProcAddr</code> intercepts a Vulkan function by returning a local entry-point
<ul>
<li>Otherwise it returns the value obtained by calling down the device call chain.</li>
<li>These additional functions must be intercepted if the layer implements device-level call chaining:
<ul>
<li><code>vkGetDeviceProcAddr</code></li>
<li><code>vkCreateDevice</code>(only required for any device-level chaining)
<ul>
<li><strong>NOTE:</strong> older layer libraries may expect that <code>vkGetInstanceProcAddr</code> ignore <code>instance</code> when <code>pName</code> is <code>vkCreateDevice</code>.</li>
</ul></li>
</ul></li>
</ul></li>
<li>The specification <strong>requires</strong> <code>NULL</code> to be returned from <code>vkGetInstanceProcAddr</code> and <code>vkGetDeviceProcAddr</code> for disabled functions.
<ul>
<li>A layer may return <code>NULL</code> itself or rely on the following layers to do so.</li>
</ul></li>
<li>A layer's implementation <code>vkGetInstanceProcAddr</code> <strong>should</strong>, when querying for <code>vkCreateInstance</code>, return a valid function pointer regardless of the value of the <code>instance</code> parameter.
<ul>
<li>The specification <strong>requires</strong> that the <code>instance</code> parameter <strong>must</strong> be NULL. However, older versions of the specification did not have this requirement, allowing for non-NULL <code>instance</code> handles to be passed in and return a valid <code>vkCreateInstance</code> function pointer. The Vulkan-Loader itself does this and will continue to do so to maintain compatibility with layers which were released before this specification change was made.</li>
</ul></li>
</ul>
<h2 id="layer-dispatch-initialization">Layer Dispatch Initialization</h2>
<ul>
<li>A layer initializes its instance dispatch table within its <code>vkCreateInstance</code> function.</li>
<li>A layer initializes its device dispatch table within its <code>vkCreateDevice</code> function.</li>
<li>The loader passes a linked list of initialization structures to layers via the "pNext" field in the <code>VkInstanceCreateInfo</code> and <code>VkDeviceCreateInfo</code> structures for <code>vkCreateInstance</code> and <code>VkCreateDevice</code> respectively.</li>
<li>The head node in this linked list is of type <code>VkLayerInstanceCreateInfo</code> for instance and VkLayerDeviceCreateInfo for device. See file <code>include/vulkan/vk_layer.h</code> for details.</li>
<li>A VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO is used by the loader for the "sType" field in <code>VkLayerInstanceCreateInfo</code>.</li>
<li>A VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO is used by the loader for the "sType" field in <code>VkLayerDeviceCreateInfo</code>.</li>
<li>The "function" field indicates how the union field "u" should be interpreted within <code>VkLayer*CreateInfo</code>. The loader will set the "function" field to VK_LAYER_LINK_INFO. This indicates "u" field should be <code>VkLayerInstanceLink</code> or <code>VkLayerDeviceLink</code>.</li>
<li>The <code>VkLayerInstanceLink</code> and <code>VkLayerDeviceLink</code> structures are the list nodes.</li>
<li>The <code>VkLayerInstanceLink</code> contains the next entity's <code>vkGetInstanceProcAddr</code> used by a layer.</li>
<li>The <code>VkLayerDeviceLink</code> contains the next entity's <code>vkGetInstanceProcAddr</code> and <code>vkGetDeviceProcAddr</code> used by a layer.</li>
<li>Given the above structures set up by the loader, layer must initialize their dispatch table as follows:
<ul>
<li>Find the <code>VkLayerInstanceCreateInfo</code>/<code>VkLayerDeviceCreateInfo</code> structure in the <code>VkInstanceCreateInfo</code>/<code>VkDeviceCreateInfo</code> structure.</li>
<li>Get the next entity's vkGet*ProcAddr from the "pLayerInfo" field.</li>
<li>For CreateInstance get the next entity's <code>vkCreateInstance</code> by calling the "pfnNextGetInstanceProcAddr": pfnNextGetInstanceProcAddr(NULL, "vkCreateInstance").</li>
<li>For CreateDevice get the next entity's <code>vkCreateDevice</code> by calling the "pfnNextGetInstanceProcAddr": pfnNextGetInstanceProcAddr(instance, "vkCreateDevice"), passing the already created instance handle.</li>
<li>Advanced the linked list to the next node: pLayerInfo = pLayerInfo-&gt;pNext.</li>
<li>Call down the chain either <code>vkCreateDevice</code> or <code>vkCreateInstance</code></li>
<li>Initialize the layer dispatch table by calling the next entity's Get*ProcAddr function once for each Vulkan function needed in the dispatch table</li>
</ul></li>
</ul>
<h2 id="example-code-for-createinstance">Example Code for CreateInstance</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1">VkResult</a>
<a class="sourceLine" id="cb11-2" title="2">   vkCreateInstance(</a>
<a class="sourceLine" id="cb11-3" title="3">      <span class="at">const</span> VkInstanceCreateInfo *pCreateInfo,</a>
<a class="sourceLine" id="cb11-4" title="4">      <span class="at">const</span> VkAllocationCallbacks *pAllocator,</a>
<a class="sourceLine" id="cb11-5" title="5">      VkInstance *pInstance)</a>
<a class="sourceLine" id="cb11-6" title="6">{</a>
<a class="sourceLine" id="cb11-7" title="7">   VkLayerInstanceCreateInfo *chain_info =</a>
<a class="sourceLine" id="cb11-8" title="8">        get_chain_info(pCreateInfo, VK_LAYER_LINK_INFO);</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="ot">assert</span>(chain_info-&gt;u.pLayerInfo);</a>
<a class="sourceLine" id="cb11-11" title="11">    PFN_vkGetInstanceProcAddr fpGetInstanceProcAddr =</a>
<a class="sourceLine" id="cb11-12" title="12">        chain_info-&gt;u.pLayerInfo-&gt;pfnNextGetInstanceProcAddr;</a>
<a class="sourceLine" id="cb11-13" title="13">    PFN_vkCreateInstance fpCreateInstance =</a>
<a class="sourceLine" id="cb11-14" title="14">        (PFN_vkCreateInstance)fpGetInstanceProcAddr(NULL, <span class="st">&quot;vkCreateInstance&quot;</span>);</a>
<a class="sourceLine" id="cb11-15" title="15">    <span class="cf">if</span> (fpCreateInstance == NULL) {</a>
<a class="sourceLine" id="cb11-16" title="16">        <span class="cf">return</span> VK_ERROR_INITIALIZATION_FAILED;</a>
<a class="sourceLine" id="cb11-17" title="17">    }</a>
<a class="sourceLine" id="cb11-18" title="18"></a>
<a class="sourceLine" id="cb11-19" title="19">    <span class="co">// Advance the link info for the next element of the chain.</span></a>
<a class="sourceLine" id="cb11-20" title="20">    <span class="co">// This ensures that the next layer gets it&#39;s layer info and not</span></a>
<a class="sourceLine" id="cb11-21" title="21">    <span class="co">// the info for our current layer.</span></a>
<a class="sourceLine" id="cb11-22" title="22">    chain_info-&gt;u.pLayerInfo = chain_info-&gt;u.pLayerInfo-&gt;pNext;</a>
<a class="sourceLine" id="cb11-23" title="23"></a>
<a class="sourceLine" id="cb11-24" title="24">    <span class="co">// Continue call down the chain</span></a>
<a class="sourceLine" id="cb11-25" title="25">    VkResult result = fpCreateInstance(pCreateInfo, pAllocator, pInstance);</a>
<a class="sourceLine" id="cb11-26" title="26">    <span class="cf">if</span> (result != VK_SUCCESS)</a>
<a class="sourceLine" id="cb11-27" title="27">        <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb11-28" title="28"></a>
<a class="sourceLine" id="cb11-29" title="29">    <span class="co">// Init layer&#39;s dispatch table using GetInstanceProcAddr of</span></a>
<a class="sourceLine" id="cb11-30" title="30">    <span class="co">// next layer in the chain.</span></a>
<a class="sourceLine" id="cb11-31" title="31">    instance_dispatch_table = <span class="kw">new</span> VkLayerInstanceDispatchTable;</a>
<a class="sourceLine" id="cb11-32" title="32">    layer_init_instance_dispatch_table(</a>
<a class="sourceLine" id="cb11-33" title="33">        *pInstance, my_data-&gt;instance_dispatch_table, fpGetInstanceProcAddr);</a>
<a class="sourceLine" id="cb11-34" title="34"></a>
<a class="sourceLine" id="cb11-35" title="35">    <span class="co">// Other layer initialization</span></a>
<a class="sourceLine" id="cb11-36" title="36">    ...</a>
<a class="sourceLine" id="cb11-37" title="37"></a>
<a class="sourceLine" id="cb11-38" title="38">    <span class="cf">return</span> VK_SUCCESS;</a>
<a class="sourceLine" id="cb11-39" title="39">}</a></code></pre></div>
<h2 id="example-code-for-createdevice">Example Code for CreateDevice</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1">VkResult</a>
<a class="sourceLine" id="cb12-2" title="2">   vkCreateDevice(</a>
<a class="sourceLine" id="cb12-3" title="3">      VkPhysicalDevice gpu,</a>
<a class="sourceLine" id="cb12-4" title="4">      <span class="at">const</span> VkDeviceCreateInfo *pCreateInfo,</a>
<a class="sourceLine" id="cb12-5" title="5">      <span class="at">const</span> VkAllocationCallbacks *pAllocator,</a>
<a class="sourceLine" id="cb12-6" title="6">      VkDevice *pDevice)</a>
<a class="sourceLine" id="cb12-7" title="7">{</a>
<a class="sourceLine" id="cb12-8" title="8">    VkInstance instance = GetInstanceFromPhysicalDevice(gpu);</a>
<a class="sourceLine" id="cb12-9" title="9">    VkLayerDeviceCreateInfo *chain_info =</a>
<a class="sourceLine" id="cb12-10" title="10">        get_chain_info(pCreateInfo, VK_LAYER_LINK_INFO);</a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12">    PFN_vkGetInstanceProcAddr fpGetInstanceProcAddr =</a>
<a class="sourceLine" id="cb12-13" title="13">        chain_info-&gt;u.pLayerInfo-&gt;pfnNextGetInstanceProcAddr;</a>
<a class="sourceLine" id="cb12-14" title="14">    PFN_vkGetDeviceProcAddr fpGetDeviceProcAddr =</a>
<a class="sourceLine" id="cb12-15" title="15">        chain_info-&gt;u.pLayerInfo-&gt;pfnNextGetDeviceProcAddr;</a>
<a class="sourceLine" id="cb12-16" title="16">    PFN_vkCreateDevice fpCreateDevice =</a>
<a class="sourceLine" id="cb12-17" title="17">        (PFN_vkCreateDevice)fpGetInstanceProcAddr(instance, <span class="st">&quot;vkCreateDevice&quot;</span>);</a>
<a class="sourceLine" id="cb12-18" title="18">    <span class="cf">if</span> (fpCreateDevice == NULL) {</a>
<a class="sourceLine" id="cb12-19" title="19">        <span class="cf">return</span> VK_ERROR_INITIALIZATION_FAILED;</a>
<a class="sourceLine" id="cb12-20" title="20">    }</a>
<a class="sourceLine" id="cb12-21" title="21"></a>
<a class="sourceLine" id="cb12-22" title="22">    <span class="co">// Advance the link info for the next element on the chain.</span></a>
<a class="sourceLine" id="cb12-23" title="23">    <span class="co">// This ensures that the next layer gets it&#39;s layer info and not</span></a>
<a class="sourceLine" id="cb12-24" title="24">    <span class="co">// the info for our current layer.</span></a>
<a class="sourceLine" id="cb12-25" title="25">    chain_info-&gt;u.pLayerInfo = chain_info-&gt;u.pLayerInfo-&gt;pNext;</a>
<a class="sourceLine" id="cb12-26" title="26"></a>
<a class="sourceLine" id="cb12-27" title="27">    VkResult result = fpCreateDevice(gpu, pCreateInfo, pAllocator, pDevice);</a>
<a class="sourceLine" id="cb12-28" title="28">    <span class="cf">if</span> (result != VK_SUCCESS) {</a>
<a class="sourceLine" id="cb12-29" title="29">        <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb12-30" title="30">    }</a>
<a class="sourceLine" id="cb12-31" title="31"></a>
<a class="sourceLine" id="cb12-32" title="32">    <span class="co">// initialize layer&#39;s dispatch table</span></a>
<a class="sourceLine" id="cb12-33" title="33">    device_dispatch_table = <span class="kw">new</span> VkLayerDispatchTable;</a>
<a class="sourceLine" id="cb12-34" title="34">    layer_init_device_dispatch_table(</a>
<a class="sourceLine" id="cb12-35" title="35">        *pDevice, device_dispatch_table, fpGetDeviceProcAddr);</a>
<a class="sourceLine" id="cb12-36" title="36"></a>
<a class="sourceLine" id="cb12-37" title="37">    <span class="co">// Other layer initialization</span></a>
<a class="sourceLine" id="cb12-38" title="38">    ...</a>
<a class="sourceLine" id="cb12-39" title="39"></a>
<a class="sourceLine" id="cb12-40" title="40">    <span class="cf">return</span> VK_SUCCESS;</a>
<a class="sourceLine" id="cb12-41" title="41">}</a></code></pre></div>
<p>In this case the function <code>GetInstanceFromPhysicalDevice</code> is called to get the instance handle. In practice, this would be done by any method a layer chooses to get an instance handle from the physical device.</p>
<h2 id="meta-layers">Meta-layers</h2>
<p>Meta-layers are a special kind of layer which is only available through the Khronos loader. While normal layers are associated with one particular library, a meta-layer is actually a collection layer which contains an ordered list of other layers (called component layers).</p>
<p>The benefits of a meta-layer are:</p>
<ol>
<li>More than one layer may be activated using a single layer name by simply grouping multiple layers in a meta-layer.</li>
<li>The order of individual component layers is loaded can be defined within the meta-layer.</li>
<li>Layer configurations (internal to the meta-layer manifest file) can easily be shared with others.</li>
<li>The loader will automatically collate all instance and device extensions in a meta-layer's component layers, and report them as the meta-layer's properties to the application when queried.</li>
</ol>
<p>Restrictions to defining and using a meta-layer are:</p>
<ol>
<li>A Meta-layer Manifest file <strong>must</strong> be a properly formatted that contains one or more component layers.</li>
<li>All component layers <strong>must be</strong> present on a system for the meta-layer to be used.</li>
<li>All component layers <strong>must be</strong> at the same Vulkan API major and minor version as the meta-layer for the meta-layer to be used.</li>
</ol>
<p>The ordering of a meta-layer's component layers in the instance or device call- chain is simple:</p>
<ul>
<li>The first layer listed will be the layer closest to the application.</li>
<li>The last layer listed will be the layer closest to the drivers.</li>
</ul>
<p>Inside the meta-layer Manifest file, each component layer is listed by its layer name. This is the "name" tag's value associated with each component layer's Manifest file under the "layer" or "layers" tag. This is also the name that would normally be used when activating a layer during <code>vkCreateInstance</code>.</p>
<p>Any duplicate layer names in either the component layer list, or globally among all enabled layers, will simply be ignored by the loader. Only the first instance of any layer name will be used.</p>
<p>For example, if a layer is enabled using the environment variable <code>VK_INSTANCE_LAYERS</code> and have that same layer listed in a meta-layer, then the environment-variable-enabled layer will be used and the component layer will be dropped. Likewise, if a person were to enable a meta-layer and then separately enable one of the component layers afterwards, the second instantiation of the layer name would be ignored.</p>
<p>The Manifest file formatting necessary to define a meta-layer can be found in the <a href="#layer-manifest-file-format">Layer Manifest File Format</a> section.</p>
<h3 id="override-meta-layer">Override Meta-Layer</h3>
<p>If an implicit meta-layer was found on the system with the name <code>VK_LAYER_LUNARG_override</code>, the loader uses it as an 'override' layer. This is used to selectively enable and disable other layers from being loaded. It can be applied globally or to a specific application or applications. The override meta layer can have the following additional keys:</p>
<ul>
<li><code>blacklisted_layers</code> - List of explicit layer names that should not be loaded even if requested by the application.</li>
<li><code>app_keys</code> - List of paths to executables that the override layer applies to.</li>
<li><code>override_paths</code> - List of paths which will be used as the search location for component layers.</li>
</ul>
<p>When an application starts up and the override layer is present, the loader first checks to see if the application is in the list. If it isn't, the override layer is not applied. If the list is empty or if <code>app_keys</code> doesn't exist, the loader makes the override layer global and applies it to every application upon startup.</p>
<p>If the override layer contains <code>override_paths</code>, then it uses this list of paths exclusively for component layers. Thus, it ignores both the default explicit and implicit layer layer search locations as well as paths set by environment variables like <code>VK_LAYER_PATH</code>. If any component layer is not present in the provided override paths, the meta layer is disabled.</p>
<p>The override meta-layer is primarily enabled when using the <a href="https://github.com/LunarG/VulkanTools/blob/main/vkconfig/README.md" TARGET="_blank">VkConfig</a> tool included in the Vulkan SDK. It is typically only available while the VkConfig tool is actually executing. Please refer to that documentation for more information.</p>
<h2 id="pre-instance-functions">Pre-Instance Functions</h2>
<p>Vulkan includes a small number of functions which are called without any dispatchable object. <b>Most layers do not intercept these functions</b>, as layers are enabled when an instance is created. However, under certain conditions it is possible for a layer to intercept these functions.</p>
<p>One reason why a layer may desire to intercept these pre-instance functions is to filter out extensions that would normally be returned from Vulkan drivers to the application. <a href="https://renderdoc.org/" TARGET="_blank">RenderDoc</a> is one such layer which intercepts these pre-instance functions so that it may disable extensions it doesn't support.</p>
<p>In order to intercept the pre-instance functions, several conditions must be met:</p>
<ul>
<li>The layer must be implicit</li>
<li>The layer manifest version must be 1.1.2 or later</li>
<li>The layer must export the entry-point symbols for each intercepted function</li>
<li>The layer manifest must specify the name of each intercepted function in a <code>pre_instance_functions</code> JSON object</li>
</ul>
<p>The functions that may be intercepted in this way are:</p>
<ul>
<li><code>vkEnumerateInstanceExtensionProperties</code></li>
<li><code>vkEnumerateInstanceLayerProperties</code></li>
<li><code>vkEnumerateInstanceVersion</code></li>
</ul>
<p>Pre-instance functions work differently from all other layer intercept functions. Other intercept functions have a function prototype identical to that of the function they are intercepting. They then rely on data that was passed to the layer at instance or device creation so that layers can call down the chain. Because there is no need to create an instance before calling the pre-instance functions, these functions must use a separate mechanism for constructing the call chain. This mechanism consists of an extra parameter that will be passed to the layer intercept function when it is called. This parameter will be a pointer to a struct, defined as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> Vk...Chain</a>
<a class="sourceLine" id="cb13-2" title="2">{</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb13-4" title="4">        VkChainType type;</a>
<a class="sourceLine" id="cb13-5" title="5">        <span class="dt">uint32_t</span> version;</a>
<a class="sourceLine" id="cb13-6" title="6">        <span class="dt">uint32_t</span> size;</a>
<a class="sourceLine" id="cb13-7" title="7">    } header;</a>
<a class="sourceLine" id="cb13-8" title="8">    PFN_vkVoidFunction pfnNextLayer;</a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="at">const</span> <span class="kw">struct</span> Vk...Chain* pNextLink;</a>
<a class="sourceLine" id="cb13-10" title="10">} Vk...Chain;</a></code></pre></div>
<p>These structs are defined in the <code>vk_layer.h</code> file so that it is not necessary to redefine the chain structs in any external code. The name of each struct is be similar to the name of the function it corresponds to, but the leading "V" is capitalized, and the word "Chain" is added to the end. For example, the struct for <code>vkEnumerateInstanceExtensionProperties</code> is called <code>VkEnumerateInstanceExtensionPropertiesChain</code>. Furthermore, the <code>pfnNextLayer</code> struct member is not actually a void function pointer — its type will be the actual type of each function in the call chain.</p>
<p>Each layer intercept function must have a prototype that is the same as the prototype of the function being intercepted, except that the first parameter must be that function's chain struct (passed as a const pointer). For example, a function that wishes to intercept <code>vkEnumerateInstanceExtensionProperties</code> would have the prototype:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1">VkResult</a>
<a class="sourceLine" id="cb14-2" title="2">   InterceptFunctionName(</a>
<a class="sourceLine" id="cb14-3" title="3">      <span class="at">const</span> VkEnumerateInstanceExtensionPropertiesChain* pChain,</a>
<a class="sourceLine" id="cb14-4" title="4">      <span class="at">const</span> <span class="dt">char</span>* pLayerName,</a>
<a class="sourceLine" id="cb14-5" title="5">      <span class="dt">uint32_t</span>* pPropertyCount,</a>
<a class="sourceLine" id="cb14-6" title="6">      VkExtensionProperties* pProperties);</a></code></pre></div>
<p>The name of the function is arbitrary; it can be anything provided that it is given in the layer manifest file (see <a href="#layer-manifest-file-format">Layer Manifest File Format</a>). The implementation of each intercept function is responsible for calling the next item in the call chain, using the chain parameter. This is done by calling the <code>pfnNextLayer</code> member of the chain struct, passing <code>pNextLink</code> as the first argument, and passing the remaining function arguments after that. For example, a simple implementation for <code>vkEnumerateInstanceExtensionProperties</code> that does nothing but call down the chain would look like:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1">VkResult</a>
<a class="sourceLine" id="cb15-2" title="2">   InterceptFunctionName(</a>
<a class="sourceLine" id="cb15-3" title="3">      <span class="at">const</span> VkEnumerateInstanceExtensionPropertiesChain* pChain,</a>
<a class="sourceLine" id="cb15-4" title="4">      <span class="at">const</span> <span class="dt">char</span>* pLayerName,</a>
<a class="sourceLine" id="cb15-5" title="5">      <span class="dt">uint32_t</span>* pPropertyCount,</a>
<a class="sourceLine" id="cb15-6" title="6">      VkExtensionProperties* pProperties)</a>
<a class="sourceLine" id="cb15-7" title="7">{</a>
<a class="sourceLine" id="cb15-8" title="8">   <span class="cf">return</span> pChain-&gt;pfnNextLayer(</a>
<a class="sourceLine" id="cb15-9" title="9">      pChain-&gt;pNextLink, pLayerName, pPropertyCount, pProperties);</a>
<a class="sourceLine" id="cb15-10" title="10">}</a></code></pre></div>
<p>When using a C++ compiler, each chain type also defines a function named <code>CallDown</code> which can be used to automatically handle the first argument. Implementing the above function using this method would look like:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1">VkResult</a>
<a class="sourceLine" id="cb16-2" title="2">   InterceptFunctionName(</a>
<a class="sourceLine" id="cb16-3" title="3">      <span class="at">const</span> VkEnumerateInstanceExtensionPropertiesChain* pChain,</a>
<a class="sourceLine" id="cb16-4" title="4">      <span class="at">const</span> <span class="dt">char</span>* pLayerName,</a>
<a class="sourceLine" id="cb16-5" title="5">      <span class="dt">uint32_t</span>* pPropertyCount,</a>
<a class="sourceLine" id="cb16-6" title="6">      VkExtensionProperties* pProperties)</a>
<a class="sourceLine" id="cb16-7" title="7">{</a>
<a class="sourceLine" id="cb16-8" title="8">   <span class="cf">return</span> pChain-&gt;CallDown(pLayerName, pPropertyCount, pProperties);</a>
<a class="sourceLine" id="cb16-9" title="9">}</a></code></pre></div>
<p>Unlike with other functions in layers, the layer may not save any global data between these function calls. Because Vulkan does not store any state until an instance has been created, all layer libraries are released at the end of each pre-instance call. This means that implicit layers can use pre-instance intercepts to modify data that is returned by the functions, but they cannot be used to record that data.</p>
<h2 id="special-considerations">Special Considerations</h2>
<h3 id="associating-private-data-with-vulkan-objects-within-a-layer">Associating Private Data with Vulkan Objects Within a Layer</h3>
<p>A layer may want to associate its own private data with one or more Vulkan objects. Two common methods to do this are hash maps and object wrapping.</p>
<h4 id="wrapping">Wrapping</h4>
<p>The loader supports layers wrapping any Vulkan object, including dispatchable objects. For functions that return object handles, each layer does not touch the value passed down the call chain. This is because lower items may need to use the original value. However, when the value is returned from a lower-level layer (possibly the driver), the layer saves the handle and returns its own handle to the layer above it (possibly the application). When a layer receives a Vulkan function using something that it previously returned a handle for, the layer is required to unwrap the handle and pass along the saved handle to the layer below it. This means that the layer <strong>must intercept every Vulkan function which uses</strong> <strong>the object in question</strong>, and wrap or unwrap the object, as appropriate. This includes adding support for all extensions with functions using any object the layer wraps as well as any loader-layer interface functions such as <code>vk_layerGetPhysicalDeviceProcAddr</code>.</p>
<p>Layers above the object wrapping layer will see the wrapped object. Layers which wrap dispatchable objects must ensure that the first field in the wrapping structure is a pointer to a dispatch table as defined in <code>vk_layer.h</code>. Specifically, an instance wrapped dispatchable object could be as follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">struct</span> <span class="va">my_wrapped_instance_obj_</span> {</a>
<a class="sourceLine" id="cb17-2" title="2">    VkLayerInstanceDispatchTable *disp;</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="co">// whatever data layer wants to add to this object</span></a>
<a class="sourceLine" id="cb17-4" title="4">};</a></code></pre></div>
<p>A device wrapped dispatchable object could be as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">struct</span> <span class="va">my_wrapped_instance_obj_</span> {</a>
<a class="sourceLine" id="cb18-2" title="2">    VkLayerDispatchTable *disp;</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="co">// whatever data layer wants to add to this object</span></a>
<a class="sourceLine" id="cb18-4" title="4">};</a></code></pre></div>
<p>Layers that wrap dispatchable objects must follow the guidelines for creating new dispatchable objects (below).</p>
<h4 id="cautions-about-wrapping">Cautions About Wrapping</h4>
<p>Layers are generally discouraged from wrapping objects, because of the potential for incompatibilities with new extensions. For example, let's say that a layer wraps <code>VkImage</code> objects, and properly wraps and unwraps <code>VkImage</code> object handles for all core functions. If a new extension is created which has functions that take <code>VkImage</code> objects as parameters, and if the layer does not support those new functions, an application that uses both the layer and the new extension will have undefined behavior when those new functions are called (e.g. the application may crash). This is because the lower-level layers and drivers won't receive the handle that they generated. Instead, they will receive a handle that is only known by the layer that is wrapping the object.</p>
<p>Because of the potential for incompatibilities with unsupported extensions, layers that wrap objects must check which extensions are being used by the application, and take appropriate action if the layer is used with unsupported extensions such as issuing a warning/error message to the user.</p>
<p>The reason that the validation layers wrap objects is to track the proper use and destruction of each object. They issue a validation error if used with unsupported extensions, alerting the user to the potential for undefined behavior.</p>
<h4 id="hash-maps">Hash Maps</h4>
<p>Alternatively, a layer may want to use a hash map to associate data with a given object. The key to the map could be the object. Alternatively, for dispatchable objects at a given level (eg device or instance) the layer may want data associated with the <code>VkDevice</code> or <code>VkInstance</code> objects. Since there are multiple dispatchable objects for a given <code>VkInstance</code> or <code>VkDevice</code>, the <code>VkDevice</code> or <code>VkInstance</code> object is not a great map key. Instead the layer should use the dispatch table pointer within the <code>VkDevice</code> or <code>VkInstance</code> since that will be unique for a given <code>VkInstance</code> or <code>VkDevice</code>.</p>
<h3 id="creating-new-dispatchable-objects">Creating New Dispatchable Objects</h3>
<p>Layers which create dispatchable objects must take special care. Remember that loader <em>trampoline</em> code normally fills in the dispatch table pointer in the newly created object. Thus, the layer must fill in the dispatch table pointer if the loader <em>trampoline</em> will not do so. Common cases where a layer (or driver) may create a dispatchable object without loader <em>trampoline</em> code is as follows:</p>
<ul>
<li>Layers that wrap dispatchable objects</li>
<li>Layers which add extensions that create dispatchable objects</li>
<li>Layers which insert extra Vulkan functions in the stream of functions they intercept from the application</li>
<li>Drivers which add extensions that create dispatchable objects</li>
</ul>
<p>The Khronos loader provides a callback that can be used for initializing a dispatchable object. The callback is passed as an extension structure via the <code>pNext</code> field in the create info structure when creating an instance (<code>VkInstanceCreateInfo</code>) or device (<code>VkDeviceCreateInfo</code>). The callback prototype is defined as follows for instance and device callbacks respectively (see <code>vk_layer.h</code>):</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1">VKAPI_ATTR VkResult VKAPI_CALL</a>
<a class="sourceLine" id="cb19-2" title="2">   vkSetInstanceLoaderData(</a>
<a class="sourceLine" id="cb19-3" title="3">      VkInstance instance,</a>
<a class="sourceLine" id="cb19-4" title="4">      <span class="dt">void</span> *object);</a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6">VKAPI_ATTR VkResult VKAPI_CALL</a>
<a class="sourceLine" id="cb19-7" title="7">   vkSetDeviceLoaderData(</a>
<a class="sourceLine" id="cb19-8" title="8">      VkDevice device,</a>
<a class="sourceLine" id="cb19-9" title="9">      <span class="dt">void</span> *object);</a></code></pre></div>
<p>To obtain these callbacks the layer must search through the list of structures pointed to by the "pNext" field in the <code>VkInstanceCreateInfo</code> and <code>VkDeviceCreateInfo</code> parameters to find any callback structures inserted by the loader. The salient details are as follows:</p>
<ul>
<li>For <code>VkInstanceCreateInfo</code> the callback structure pointed to by "pNext" is <code>VkLayerInstanceCreateInfo</code> as defined in <code>include/vulkan/vk_layer.h</code>.</li>
<li>A "sType" field in of VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO within <code>VkInstanceCreateInfo</code> parameter indicates a loader structure.</li>
<li>Within <code>VkLayerInstanceCreateInfo</code>, the "function" field indicates how the union field "u" should be interpreted.</li>
<li>A "function" equal to VK_LOADER_DATA_CALLBACK indicates the "u" field will contain the callback in "pfnSetInstanceLoaderData".</li>
<li>For <code>VkDeviceCreateInfo</code> the callback structure pointed to by "pNext" is <code>VkLayerDeviceCreateInfo</code> as defined in <code>include/vulkan/vk_layer.h</code>.</li>
<li>A "sType" field in of VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO within <code>VkDeviceCreateInfo</code> parameter indicates a loader structure.</li>
<li>Within <code>VkLayerDeviceCreateInfo</code>, the "function" field indicates how the union field "u" should be interpreted.</li>
<li>A "function" equal to VK_LOADER_DATA_CALLBACK indicates the "u" field will contain the callback in "pfnSetDeviceLoaderData".</li>
</ul>
<p>Alternatively, if an older loader is being used that doesn't provide these callbacks, the layer may manually initialize the newly created dispatchable object. To fill in the dispatch table pointer in newly created dispatchable object, the layer should copy the dispatch pointer, which is always the first entry in the structure, from an existing parent object of the same level (instance versus device).</p>
<p>For example, if there is a newly created <code>VkCommandBuffer</code> object, then the dispatch pointer from the <code>VkDevice</code> object, which is the parent of the <code>VkCommandBuffer</code> object, should be copied into the newly created object.</p>
<h3 id="versioning-and-activation-interactions">Versioning and Activation Interactions</h3>
<p>There are several interacting rules concerning the activation of layers with non-obvious results. This not an exhaustive list but should better clarify the behavior of the loader in complex situations.</p>
<ul>
<li><p>The Vulkan Loader in versions 1.3.228 and above will enable implicit layers regardless of the API version specified by the application in <code>VkApplicationInfo::apiVersion</code>. Previous loader versions (1.3.227 and below) used to have a requirement where implicit layer's API version must be equal to or greater than the API version of the application for the layer to be enabled. The change relaxed the implicit layer loading requirements because it was determined that the perceived protection of preventing older layers running with newer applications wasn't enough to justify the friction it caused. This was due to older layers no longer working with newer applications for no apparent reason, as well as older layers having to update the manifest to work with newer applications. The layer didn't need to do anything else to get their layer working again, which meant that a layer didn't need to prove that their layer worked with newer API versions. Thus, the disabling caused confusion for users but didn't protect them from potentially badly behaving layers.</p></li>
<li><p>An implicit layer will ignore its disable environment variable being set if it is a component in an active meta layer.</p></li>
<li><p>The environment <code>VK_LAYER_PATH</code> only affects explicit layer searching, not implicit. Layers found in this path are treated as explicit, even if they contain all the requisite fields to be an implicit layer. This means they will not be implicitly enabled.</p></li>
<li><p>Meta layers do not have to be implicit - they can be explicit. It cannot be assumed that because a meta layer is present that it will be active.</p></li>
<li><p>The <code>blacklisted_layers</code> member of the override meta layer will prevent both implicitly enabled and explicitely enabled layers from activating. Any layers in an application's <code>VkInstanceCreateInfo::ppEnabledLayerNames</code> that are in the blacklist will not be enabled.</p></li>
<li><p>The <code>app_keys</code> member of the override meta layer will make a meta layer apply to only applications found in this list. If there are any items in the app keys list, the meta layer isn't enabled for any application except those found in the list.</p></li>
<li><p>The <code>override_paths</code> member of the override meta layer, if present, will replace the search paths the loader uses to find component layers. If any component layer isn't present in the override paths, the override meta layer is not applied. So if an override meta layer wants to mix default and custom layer locations, the override paths must contain both custom and default layer locations.</p></li>
<li><p>If the override layer is both present and contains <code>override_paths</code>, the paths from the environment variable <code>VK_LAYER_PATH</code> are ignored when searching for explicit layers. For example, when both the meta layer override paths and <code>VK_LAYER_PATH</code> are present, none of the layers in <code>VK_LAYER_PATH</code> are discoverable, and the loader will not find them.</p></li>
</ul>
<h2 id="layer-manifest-file-format">Layer Manifest File Format</h2>
<p>The Khronos loader uses manifest files to discover available layer libraries and layers. It doesn't directly query the layer's dynamic library except during chaining. This is to reduce the likelihood of loading a malicious layer into memory. Instead, details are read from the Manifest file, which are then provided for applications to determine what layers should actually be loaded.</p>
<p>The following section discusses the details of the Layer Manifest JSON file format. The JSON file itself does not have any requirements for naming. The only requirement is that the extension suffix of the file is ".json".</p>
<p>Here is an example layer JSON Manifest file with a single layer:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb20-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">   <span class="dt">&quot;file_format_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1.2.1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-3" title="3">   <span class="dt">&quot;layer&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-4" title="4">       <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_LAYER_LUNARG_overlay&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-5" title="5">       <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;INSTANCE&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-6" title="6">       <span class="dt">&quot;library_path&quot;</span><span class="fu">:</span> <span class="st">&quot;vkOverlayLayer.dll&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-7" title="7">       <span class="dt">&quot;library_arch&quot;</span> <span class="fu">:</span> <span class="st">&quot;64&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-8" title="8">       <span class="dt">&quot;api_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1.0.5&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-9" title="9">       <span class="dt">&quot;implementation_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;2&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-10" title="10">       <span class="dt">&quot;description&quot;</span> <span class="fu">:</span> <span class="st">&quot;LunarG HUD layer&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-11" title="11">       <span class="dt">&quot;functions&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-12" title="12">           <span class="dt">&quot;vkNegotiateLoaderLayerInterfaceVersion&quot;</span><span class="fu">:</span></a>
<a class="sourceLine" id="cb20-13" title="13">               <span class="st">&quot;OverlayLayer_NegotiateLoaderLayerInterfaceVersion&quot;</span></a>
<a class="sourceLine" id="cb20-14" title="14">       <span class="fu">},</span></a>
<a class="sourceLine" id="cb20-15" title="15">       <span class="dt">&quot;instance_extensions&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb20-16" title="16">           <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-17" title="17">               <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_EXT_debug_report&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-18" title="18">               <span class="dt">&quot;spec_version&quot;</span><span class="fu">:</span> <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb20-19" title="19">           <span class="fu">}</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb20-20" title="20">           <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-21" title="21">               <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_VENDOR_ext_x&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-22" title="22">               <span class="dt">&quot;spec_version&quot;</span><span class="fu">:</span> <span class="st">&quot;3&quot;</span></a>
<a class="sourceLine" id="cb20-23" title="23">            <span class="fu">}</span></a>
<a class="sourceLine" id="cb20-24" title="24">       <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-25" title="25">       <span class="dt">&quot;device_extensions&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb20-26" title="26">           <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-27" title="27">               <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_EXT_debug_marker&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-28" title="28">               <span class="dt">&quot;spec_version&quot;</span><span class="fu">:</span> <span class="st">&quot;1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-29" title="29">               <span class="dt">&quot;entrypoints&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;vkCmdDbgMarkerBegin&quot;</span><span class="ot">,</span> <span class="st">&quot;vkCmdDbgMarkerEnd&quot;</span><span class="ot">]</span></a>
<a class="sourceLine" id="cb20-30" title="30">           <span class="fu">}</span></a>
<a class="sourceLine" id="cb20-31" title="31">       <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb20-32" title="32">       <span class="dt">&quot;enable_environment&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-33" title="33">           <span class="dt">&quot;ENABLE_LAYER_OVERLAY_1&quot;</span><span class="fu">:</span> <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb20-34" title="34">       <span class="fu">},</span></a>
<a class="sourceLine" id="cb20-35" title="35">       <span class="dt">&quot;disable_environment&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb20-36" title="36">           <span class="dt">&quot;DISABLE_LAYER_OVERLAY_1&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb20-37" title="37">       <span class="fu">}</span></a>
<a class="sourceLine" id="cb20-38" title="38">   <span class="fu">}</span></a>
<a class="sourceLine" id="cb20-39" title="39"><span class="fu">}</span></a></code></pre></div>
<p>Here's a snippet with the changes required to support multiple layers per manifest file:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb21-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb21-2" title="2">   <span class="dt">&quot;file_format_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1.0.1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb21-3" title="3">   <span class="dt">&quot;layers&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb21-4" title="4">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb21-5" title="5">           <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_LAYER_layer_name1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb21-6" title="6">           <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;INSTANCE&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb21-7" title="7">           <span class="er">...</span></a>
<a class="sourceLine" id="cb21-8" title="8">      <span class="fu">}</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb21-9" title="9">      <span class="fu">{</span></a>
<a class="sourceLine" id="cb21-10" title="10">           <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_LAYER_layer_name2&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb21-11" title="11">           <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;INSTANCE&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb21-12" title="12">           <span class="er">...</span></a>
<a class="sourceLine" id="cb21-13" title="13">      <span class="fu">}</span></a>
<a class="sourceLine" id="cb21-14" title="14">   <span class="ot">]</span></a>
<a class="sourceLine" id="cb21-15" title="15"><span class="fu">}</span></a></code></pre></div>
<p>Here's an example of a meta-layer manifest file:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb22-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb22-2" title="2">   <span class="dt">&quot;file_format_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1.1.1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-3" title="3">   <span class="dt">&quot;layer&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb22-4" title="4">       <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;VK_LAYER_META_layer&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-5" title="5">       <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;GLOBAL&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-6" title="6">       <span class="dt">&quot;api_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1.0.40&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-7" title="7">       <span class="dt">&quot;implementation_version&quot;</span> <span class="fu">:</span> <span class="st">&quot;1&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-8" title="8">       <span class="dt">&quot;description&quot;</span> <span class="fu">:</span> <span class="st">&quot;LunarG Meta-layer example&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb22-9" title="9">       <span class="dt">&quot;component_layers&quot;</span><span class="fu">:</span> <span class="ot">[</span></a>
<a class="sourceLine" id="cb22-10" title="10">           <span class="st">&quot;VK_LAYER_KHRONOS_validation&quot;</span><span class="ot">,</span></a>
<a class="sourceLine" id="cb22-11" title="11">           <span class="st">&quot;VK_LAYER_LUNARG_api_dump&quot;</span></a>
<a class="sourceLine" id="cb22-12" title="12">       <span class="ot">]</span></a>
<a class="sourceLine" id="cb22-13" title="13">   <span class="fu">}</span></a>
<a class="sourceLine" id="cb22-14" title="14"><span class="fu">}</span></a></code></pre></div>
<table style="width:100%">
  <tr>
    <th>JSON Node</th>
    <th>Description and Notes</th>
    <th>Restrictions</th>
    <th>Parent</th>
    <th>Introspection Query</th>
  </tr>
  <tr>
    <td>"api_version"</td>
    <td>The major.minor.patch version number of the Vulkan API that the layer
        supports.
        It does not require the application to make use of that API version.
        It simply is an indication that the layer can support Vulkan API
        instance and device functions up to and including that API version.</br>
        For example: 1.0.33.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"app_keys"</td>
    <td>List of paths to executables that the meta-layer applies to.
    </td>
    <td><b>Meta-layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"blacklisted_layers"</td>
    <td>List of explicit layer names that should not be loaded even if
        requested by the application.
    </td>
    <td><b>Meta-layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"component_layers"</td>
    <td>Indicates the component layer names that are
        part of a meta-layer.
        The names listed must be the "name" identified in each of the component
        layer's Mainfest file "name" tag (this is the same as the name of the
        layer that is passed to the `vkCreateInstance` command).
        All component layers must be present on the system and found by the
        loader in order for this meta-layer to be available and activated. <br/>
        <b>This field must not be present if "library_path" is defined</b>.
    </td>
    <td><b>Meta-layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"description"</td>
    <td>A high-level description of the layer and its intended use.</td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"device_extensions"</td>
    <td><b>OPTIONAL:</b> Contains the list of device extension names supported
        by this layer. One "device\_extensions" node with an array of one or
        more elements is required if any device extensions are supported by a
        layer; otherwise the node is optional.
        Each element of the array must have the nodes "name" and "spec_version"
        which correspond to `VkExtensionProperties` "extensionName" and
        "specVersion" respectively.
        Additionally, each element of the array of device extensions must have
        the node "entrypoints" if the device extension adds Vulkan API
        functions; otherwise this node is not required.
        The "entrypoint" node is an array of the names of all entry-points added
        by the supported extension.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateDeviceExtensionProperties</small></td>
  </tr>
  <tr>
    <td>"disable_environment"</td>
    <td><b>REQUIRED:</b> Indicates an environment variable used to disable the
        Implicit Layer (when defined to any non-empty string value).<br/>
        In rare cases of an application not working with an implicit layer, the
        application can set this environment variable (before calling Vulkan
        functions) in order to "blacklist" the layer.
        This environment variable (which may vary with each variation of the
        layer) must be set (not particularly to any value).
        If both the "enable_environment" and "disable_environment" variables are
        set, the implicit layer is disabled.
    </td>
    <td><b>Implicit Layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"enable_environment"</td>
    <td><b>OPTIONAL:</b> Indicates an environment variable used to enable the
        Implicit Layer (when defined to any non-empty string value).<br/>
        This environment variable (which may vary with each variation of the
        layer) must be set to the given value or else the implicit layer is not
        loaded.
        This is for application environments (e.g. Steam) which want to enable a
        layer(s) only for applications that they launch, and allows for
        applications run outside of an application environment to not get that
        implicit layer(s).
    </td>
    <td><b>Implicit Layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"file_format_version"</td>
    <td>Manifest format major.minor.patch version number.<br/>
        Supported versions are: 1.0.0, 1.0.1, 1.1.0, 1.1.1, 1.1.2 and 1.2.0.
    </td>
    <td>None</td>
    <td>None</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"functions"</td>
    <td><b>OPTIONAL:</b> This section can be used to identify a different
        function name for the loader to use in place of standard layer interface
        functions.
        The "functions" node is required if the layer is using an alternative
        name for `vkNegotiateLoaderLayerInterfaceVersion`.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkGet*ProcAddr</small></td>
  </tr>
  <tr>
    <td>"implementation_version"</td>
    <td>The version of the layer implemented.
        If the layer itself has any major changes, this number should change so
        the loader and/or application can identify it properly.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"instance_extensions"</td>
    <td><b>OPTIONAL:</b> Contains the list of instance extension names
        supported by this layer.
        One "instance_extensions" node with an array of one or more elements is
        required if any instance extensions are supported by a layer; otherwise
        the node is optional.
        Each element of the array must have the nodes "name" and "spec_version"
        which correspond to `VkExtensionProperties` "extensionName" and
        "specVersion" respectively.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstanceExtensionProperties</small></td>
  </tr>
  <tr>
    <td>"layer"</td>
    <td>The identifier used to group a single layer's information together.
    </td>
    <td>None</td>
    <td>None</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"layers"</td>
    <td>The identifier used to group multiple layers' information together.
        This requires a minimum Manifest file format version of 1.0.1.
    </td>
    <td>None</td>
    <td>None</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"library_path"</td>
    <td>Specifies either a filename, a relative pathname, or a full pathname to
        a layer shared library file.
        If "library_path" specifies a relative pathname, it is relative to the
        path of the JSON manifest file (e.g. for cases when an application
        provides a layer that is in the same folder hierarchy as the rest of the
        application files).
        If "library_path" specifies a filename, the library must live in the
        system's shared object search path.
        There are no rules about the name of the layer shared library files
        other than it should end with the appropriate suffix (".DLL" on Windows,
        ".so" on Linux, and ".dylib" on macOS).<br/>
        <b>This field must not be present if "component_layers" is defined</b>.
    </td>
    <td><b>Not Valid For Meta-layers</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <td>"library_arch"</td>
    <td>Optional field which specifies the architecture of the binary associated
        with "library_path". <br />
        Allows the loader to quickly determine if the architecture of the layer
        matches that of the running application. <br />
        The only valid values are "32" and "64".</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
  <tr>
    <td>"name"</td>
    <td>The string used to uniquely identify this layer to applications.</td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstanceLayerProperties</small></td>
  </tr>
  <tr>
    <td>"override_paths"</td>
    <td>List of paths which will be used as the search location for component
        layers.
    </td>
    <td><b>Meta-layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td>"pre_instance_functions"</td>
    <td><b>OPTIONAL:</b> Indicates which functions the layer wishes to
        intercept, that do not require that an instance has been created.
        This should be an object where each function to be intercepted is
        defined as a string entry where the key is the Vulkan function name and
        the value is the name of the intercept function in the layer's dynamic
        library.
        Available in layer manifest versions 1.1.2 and up. <br/>
        See <a href="#pre-instance-functions">Pre-Instance Functions</a> for
        more information.
    </td>
    <td><b>Implicit Layers Only</b></td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerateInstance*Properties</small></td>
  </tr>
  <tr>
    <td>"type"</td>
    <td>This field indicates the type of layer.  The values can be: GLOBAL, or
        INSTANCE.<br/>
        <b> NOTE: </b> Prior to deprecation, the "type" node was used to
        indicate which layer chain(s) to activate the layer upon: instance,
        device, or both.
        Distinct instance and device layers are deprecated; there are now just
        instance layers.
        Originally, allowable values were "INSTANCE", "GLOBAL" and, "DEVICE."
        But now "DEVICE" layers are skipped over by the loader as if they were
        not found.
    </td>
    <td>None</td>
    <td>"layer"/"layers"</td>
    <td><small>vkEnumerate*LayerProperties</small></td>
  </tr>
</table>

<h3 id="layer-manifest-file-version-history">Layer Manifest File Version History</h3>
<p>The current highest supported Layer Manifest file format supported is 1.2.0. Information about each version is detailed in the following sub-sections:</p>
<h3 id="layer-manifest-file-version-121">Layer Manifest File Version 1.2.1</h3>
<p>Added the "library_arch" field to the layer manifest to allow the loader to quickly determine if the layer matches the architecture of the current running application.</p>
<h4 id="layer-manifest-file-version-120">Layer Manifest File Version 1.2.0</h4>
<p>The ability to define the layer settings as defined by the <a href="https://github.com/LunarG/VulkanTools/blob/main/vkconfig_core/layers/layers_schema.json" TARGET="_blank">layer manifest schema</a>.</p>
<p>The ability to briefly document the layer thanks to the fields:</p>
<ul>
<li>"introduction": Presentation of the purpose of the layer in a paragraph.</li>
<li>"url": A link the the layer home page.</li>
<li>"platforms": The list of supported platforms of the layer</li>
<li>"status": The life cycle of the layer: Alpha, Beta, Stable, or Deprecated</li>
</ul>
<p>These changes were made to enable third-party layers to expose their features within <a href="https://github.com/LunarG/VulkanTools/blob/main/vkconfig/README.md" TARGET="_blank">Vulkan Configurator</a> or other tools.</p>
<h4 id="layer-manifest-file-version-112">Layer Manifest File Version 1.1.2</h4>
<p>Version 1.1.2 introduced the ability of layers to intercept function calls that do not have an instance.</p>
<h4 id="layer-manifest-file-version-111">Layer Manifest File Version 1.1.1</h4>
<p>The ability to define custom metalayers was added. To support metalayers, the "component_layers" section was added, and the requirement for a "library_path" section to be present was removed when the "component_layers" section is present.</p>
<h4 id="layer-manifest-file-version-110">Layer Manifest File Version 1.1.0</h4>
<p>Layer Manifest File Version 1.1.0 is tied to changes exposed by the Loader/Layer interface version 2.</p>
<ol>
<li>Renaming "vkGetInstanceProcAddr" in the "functions" section is deprecated since the loader no longer needs to query the layer about "vkGetInstanceProcAddr" directly. It is now returned during the layer negotiation, so this field will be ignored.</li>
<li>Renaming "vkGetDeviceProcAddr" in the "functions" section is deprecated since the loader no longer needs to query the layer about "vkGetDeviceProcAddr" directly. It too is now returned during the layer negotiation, so this field will be ignored.</li>
<li>Renaming the "vkNegotiateLoaderLayerInterfaceVersion" function is being added to the "functions" section, since this is now the only function the loader needs to query using OS-specific calls.
<ul>
<li>NOTE: This is an optional field and, as the two previous fields, only needed if the layer requires changing the name of the function for some reason.</li>
</ul></li>
</ol>
<p>The layer manifest file does not need to to be updated if the names of any listed functions has not changed.</p>
<h4 id="layer-manifest-file-version-101">Layer Manifest File Version 1.0.1</h4>
<p>The ability to define multiple layers using the "layers" array was added. This JSON array field can be used when defining a single layer or multiple layers. The "layer" field is still present and valid for a single layer definition.</p>
<h4 id="layer-manifest-file-version-100">Layer Manifest File Version 1.0.0</h4>
<p>The initial version of the layer manifest file specified the basic format and fields of a layer JSON file. The fields of the 1.0.0 file format include:</p>
<ul>
<li>"file_format_version"</li>
<li>"layer"</li>
<li>"name"</li>
<li>"type"</li>
<li>"library_path"</li>
<li>"api_version"</li>
<li>"implementation_version"</li>
<li>"description"</li>
<li>"functions"</li>
<li>"instance_extensions"</li>
<li>"device_extensions"</li>
<li>"enable_environment"</li>
<li>"disable_environment"</li>
</ul>
<p>It was also during this time that the value of "DEVICE" was deprecated from the "type" field.</p>
<h2 id="layer-interface-versions">Layer Interface Versions</h2>
<p>The current loader/layer interface is at version 2. The following sections detail the differences between the various versions.</p>
<h3 id="layer-interface-version-2">Layer Interface Version 2</h3>
<p>Introduced the concept of <a href="#layer-version-negotiation">loader and layer interface</a> using the <code>vkNegotiateLoaderLayerInterfaceVersion</code> function. Additionally, it introduced the concept of <a href="#layer-unknown-physical-device-extensions">Layer Unknown Physical Device Extensions</a> and the associated <code>vk_layerGetPhysicalDeviceProcAddr</code> function. Finally, it changed the manifest file definition to 1.1.0.</p>
<p>Note: If a layer wraps the VkInstance handle, support for <code>vk_layerGetPhysicalDeviceProcAddr</code> is <em>NOT</em> optional and must be implemented.</p>
<h3 id="layer-interface-version-1">Layer Interface Version 1</h3>
<p>A layer supporting interface version 1 had the following behavior:</p>
<ol>
<li><code>vkGetInstanceProcAddr</code> and <code>vkGetDeviceProcAddr</code> were directly exported</li>
<li>The layer manifest file was able to override the names of the <code>GetInstanceProcAddr</code> and <code>GetDeviceProcAddr</code>functions.</li>
</ol>
<h3 id="layer-interface-version-0">Layer Interface Version 0</h3>
<p>A layer supporting interface version 0 must define and export these introspection functions, unrelated to any Vulkan function despite the names, signatures, and other similarities:</p>
<ul>
<li><code>vkEnumerateInstanceLayerProperties</code> enumerates all layers in a <code>Layer Library</code>.
<ul>
<li>This function never fails.</li>
<li>When the <code>Layer Library</code> contains only one layer, this function may be an alias to that one layer's <code>vkEnumerateInstanceLayerProperties</code>.</li>
</ul></li>
<li><code>vkEnumerateInstanceExtensionProperties</code> enumerates instance extensions of layers in the <code>Layer Library</code>.
<ul>
<li>"pLayerName" is always a valid layer name.</li>
<li>This function never fails.</li>
<li>When the <code>Layer Library</code> contains only one layer, this function may be an alias to the one layer's <code>vkEnumerateInstanceExtensionProperties</code>.</li>
</ul></li>
<li><code>vkEnumerateDeviceLayerProperties</code> enumerates a subset (can be full, proper, or empty subset) of layers in the <code>Layer Library</code>.
<ul>
<li>"physicalDevice" is always <code>VK_NULL_HANDLE</code>.</li>
<li>This function never fails.</li>
<li>If a layer is not enumerated by this function, it will not participate in device function interception.</li>
</ul></li>
<li><code>vkEnumerateDeviceExtensionProperties</code> enumerates device extensions of layers in the <code>Layer Library</code>.
<ul>
<li>"physicalDevice" is always <code>VK_NULL_HANDLE</code>.</li>
<li>"pLayerName" is always a valid layer name.</li>
<li>This function never fails.</li>
</ul></li>
</ul>
<p>It must also define and export these functions once for each layer in the library:</p>
<ul>
<li><p><code>&lt;layerName&gt;GetInstanceProcAddr(instance, pName)</code> behaves identically to a layer's vkGetInstanceProcAddr except it is exported.</p>
<p>When the <code>Layer Library</code> contains only one layer, this function may alternatively be named <code>vkGetInstanceProcAddr</code>.</p></li>
<li><p><code>&lt;layerName&gt;GetDeviceProcAddr</code> behaves identically to a layer's vkGetDeviceProcAddr except it is exported.</p>
<p>When the <code>Layer Library</code> contains only one layer, this function may alternatively be named <code>vkGetDeviceProcAddr</code>.</p></li>
</ul>
<p>All layers contained within a library must support <code>vk_layer.h</code>. They do not need to implement functions that they do not intercept. They are recommended not to export any functions.</p>
<h2 id="loader-and-layer-interface-policy">Loader and Layer Interface Policy</h2>
<p>This section is intended to define proper behavior expected between the loader and layers. Much of this section is additive to the Vulkan spec, and necessary for maintaining consistency across platforms. In fact, much of the language can be found throughout this document, but is summarized here for convenience. Additionally, there should be a way to identify bad or non-conformant behavior in a layer and remedy it as soon as possible. Therefore, a policy numbering system is provided to clearly identify each policy statement in a unique way.</p>
<p>Finally, based on the goal of making the loader efficient and performant, some of these policy statements defining proper layer behavior may not be testable (and therefore aren't enforceable by the loader). However, that should not detract from the requirement in order to provide the best experience to end-users and developers.</p>
<h3 id="number-format">Number Format</h3>
<p>Loader/Layer policy items start with the prefix <code>LLP_</code> (short for Loader/Layer Policy) which is followed by an identifier based on what component the policy is targeted against. In this case there are only two possible components:</p>
<ul>
<li>Layers: which will have the string <code>LAYER_</code> as part of the policy number.</li>
<li>The Loader: which will have the string <code>LOADER_</code> as part of the policy number.</li>
</ul>
<h3 id="android-differences">Android Differences</h3>
<p>As stated before, the Android Loader is actually separate from the Khronos Loader. Because of this and other platform requirements, not all of these policy statements apply to Android. Each table also has a column titled "Applicable to Android?" which indicates which policy statements apply to layers that are focused only on Android support. Further information on the Android loader can be found in the <a href="https://source.android.com/devices/graphics/implement-vulkan" TARGET="_blank"> Android Vulkan documentation</a>.</p>
<h3 id="requirements-of-well-behaved-layers">Requirements of Well-Behaved Layers</h3>
<table style="width:100%">
  <tr>
    <th>Requirement Number</th>
    <th>Requirement Description</th>
    <th>Result of Non-Compliance</th>
    <th>Applicable to Android?</th>
    <th>Enforceable by Loader?</th>
    <th>Reference Section</th>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_1</b></small></td>
    <td>A layer, when inserted into an otherwise compliant Vulkan
        environment, <b>must</b> still result in a compliant Vulkan environment
        unless it intends to mimic non-compliant behavior (such as a device
        simulation layer).
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>No<br/>
        It is not a simple task for the loader to find the cause of failure
        in a layer chain.</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_2</b></small></td>
    <td>A layer <b>must not</b> cause other layers or drivers to fail, crash, or
        otherwise misbehave.<br/>
        It <b>must not</b> make invalid calls to, or rely on undefined behaviors
        of the layers or drivers below it.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>No<br/>
        It is not a simple task for the loader to find the cause of failure
        in a layer chain.</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_3</b></small></td>
    <td>Any new layer developed <b>should</b> adhere to the naming rules defined
        in the "Layer Conventions and Rules" section which also correspond to
        the naming rules defined in the Vulkan Style Guide section 3.4 on
        "Version, Extension, and Layer Naming Conventions".
    </td>
    <td>Layer developers could produce conflicting names causing unexpected
        behavior if more than one layer with the same name is available on a
        user's platform.
    </td>
    <td>Yes</td>
    <td>Yes<br/>
        Can not immediately enforce since it will cause some shipping layers
        to stop working.</td>
    <td><small>
        <a href="https://www.khronos.org/registry/vulkan/specs/1.2/styleguide.html#extensions-naming-conventions" TARGET="_blank">
            Vulkan Style Guide section 3.4</a> <br/>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_4</b></small></td>
    <td>A layer <b>should</b> export the
        <i>vkNegotiateLoaderLayerInterfaceVersion</i> entry-point to negotiate
        an interface version.<br/>
        A layer using interface 2 or newer <b>must</b> export this function.<br/>
    </td>
    <td>The layer will not be loaded.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-version-negotiation">Layer Version Negotiation</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_5</b></small></td>
    <td>A layer <b>must</b> be able to negotiate a supported version of the
        loader/layer interface with the loader in accordance with the stated
        negotiation process.
    </td>
    <td>The layer will not be loaded.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>
        <a href="#loader-and-layer-interface-negotiation">
        Interface Negotiation</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_6</b></small></td>
    <td>A layer <b>must</b> have a valid JSON manifest file for the
        loader to process that ends with the ".json" suffix.
        It is recommended validating the layer manifest file against
        <a href="https://github.com/LunarG/VulkanTools/blob/main/vkconfig_core/layers/layers_schema.json" TARGET="_blank">
        the layer schema</a> prior to publication.</br>
        The <b>only</b> exception is on Android which determines layer
        functionality through the introspection functions defined in
        <a href="#layer-library-api-version-0">Layer Library API Version 0</a>
        section and in the
        <a href="#layer-manifest-file-format">Layer Manifest File Format</a>
        table.
    </td>
    <td>The layer will not be loaded.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-manifest-file-usage">Manifest File Usage</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_7</b></small></td>
    <td>If a layer is a Meta-layer, each component layer in its manifest file
        <b>must</b> be present on the system.
    </td>
    <td>The layer will not be loaded.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>
        <a href="#meta-layers">Meta-Layers</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_8</b></small></td>
    <td>If a layer is a Meta-layer, each component layer in its manifest file
        <b>must</b> report the same or a newer Vulkan API major and minor
        version than the meta-layer.
    </td>
    <td>The layer will not be loaded.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>
        <a href="#meta-layers">Meta-Layers</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_9</b></small></td>
    <td>A layer installed as an Implicit Layer <b>must</b> define a disable
        environment variable so it can be disabled globally.
    </td>
    <td>The layer will not be loaded if it does not define the environment
        variable.
    </td>
    <td>Yes</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-manifest-file-format">Manifest File Format</a>, see
        "disable_environment" variable</small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_10</b></small></td>
    <td>If a layer wraps individual object handles, it <b>must</b> unwrap those
        handles when passing the handles down the chain to the next layer.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    </td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
      <a href="#cautions-about-wrapping">Cautions About Wrapping</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_11</b></small></td>
    <td>Any layer shipped with a driver <b>must</b> be validated against
        conformance with the corresponding driver.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
        <a href="https://github.com/KhronosGroup/VK-GL-CTS/blob/main/external/openglcts/README.md" TARGET="_blank">
        Vulkan CTS Documentation</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_12</b></small></td>
    <td> During <i>vkCreateInstance</i>, a layer <b>must</b> process the
         <i>VkLayerInstanceCreateInfo</i> chain links appropriately.<br/>
         This includes getting the next layer's <i>vkGetInstanceProcAddr</i>
         function for building a dispatch table as well as updating the
         <i>VkLayerInstanceCreateInfo</i> chain link to point to the next
         structure in the chain for the next layer prior to calling down to the
         next layer's <i>vkCreateInstance</i> function. <br/>
         An example of such usage is shown in detail in the
         <a href=#example-code-for-createinstance>Example Code for
         CreateInstance</a> section.
    </td>
    <td>The behavior will result in crashes or corruption as any following
        layers will access incorrect content.</td>
    <td>Yes</td>
    <td>No<br/>
        With the current loader/layer design, it is difficult for the loader
        to diagnose this without adding additional overhead that could impact
        performance.<br/>
        This is because the loader calls all layers at once and has no data on
        the intermediate state of the <i>pNext</i> chain contents.
        This could be done in the future, but requires re-designing the layer
        initialization process.
    </td>
    <td><small>
        <a href=""#layer-dispatch-initialization">
           Layer Dispatch Initialization</a>
        </small>
    </td>
  </tr>
    <td><small><b>LLP_LAYER_13</b></small></td>
    <td> During <i>vkCreateDevice</i>, a layer <b>must</b> process the
         <i>VkLayerDeviceCreateInfo</i> chain links appropriately.<br/>
         This includes updating the <i>VkLayerDeviceCreateInfo</i> chain link to
         point to the next structure in the chain for the next layer prior to
         calling down to the next layer's <i>vkCreateDevice</i> function. <br/>
         An example of such usage is shown in detail in the
         <a href="#example-code-for-createdevice">Example Code for
         CreateDevice</a> section.
    </td>
    <td>The behavior will result in crashes or corruption as any following
        layers will access incorrect content.</td>
    <td>Yes</td>
    <td>No<br/>
        With the current loader/layer design, it is difficult for the loader
        to diagnose this without adding additional overhead that could impact
        performance.</td>
    <td><small>
        <a href="#layer-dispatch-initialization">
           Layer Dispatch Initialization</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_14</b></small></td>
    <td>A layer <b>should</b> use the application provided memory allocator
        functions when they are provided so that applications can keep track of
        allocated memory.
    </td>
    <td>The allocator functions may be provided for the purpose of limiting
        or tracking the memory used by the Vulkan components.
        Because of this, if a layer ignores these allocators, it may result in
        undefined behavior possibly including crashes or corruption.
    </td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_15</b></small></td>
    <td>A layer <b>must</b> enumerate only its own extension properties during a
        call of <i>vkEnumerateInstanceExtensionProperties</i> when
        <i>pLayerName</i> refers to itself.<br/>
        Otherwise, it <b>must</b> return <i>VK_ERROR_LAYER_NOT_PRESENT</i>,
        including when <i>pLayerName</i> is <b>NULL</b>.
    </td>
    <td>The loader could become confused on what support is present in a
        specific layer which will result in undefined behavior possibly
        including crashes or corruption.
    </td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_16</b></small></td>
    <td>A layer <b>must</b> enumerate only its own extension properties during a
        call of <i>vkEnumerateDeviceExtensionProperties</i> when
        <i>pLayerName</i> refers to itself.<br/>
        Otherwise, it <b>must</b> ignore the call other than passing it down
        the standard call chain.
    </td>
    <td>The loader could become confused on what support is present in a
        specific layer which will result in undefined behavior possibly
        including crashes or corruption.
    </td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_17</b></small></td>
    <td>A layer's <i>vkCreateInstance</i> <b>must not</b> generate an error for
        unrecognized extension names as the extension could be implemented by
        a lower layer or driver.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_18</b></small></td>
    <td>A layer <b>must</b> return <b>NULL</b> from <i>vkGetInstanceProcAddr</i>
        or <i>vkGetDeviceProcAddr</i> for entry-points that it does not support
        or that have not been enabled properly (for example not enabling the
        extension certain entry-points are associated with should result in
        <i>vkGetInstanceProcAddr</i> returning <b>NULL</b> when requesting
        them).
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>No<br/>
        With the current loader/layer design, it is difficult for the loader
        to determine this without adding additional overhead that could impact
        performance.</td>
    <td><small>
        <a href="#layer-conventions-and-rules">Layer Conventions and Rules</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_19</b></small></td>
    <td>If a layer creates dispatchable objects, either because it is
        wrapping objects or implementing an extension not supported by
        the loader or underlying drivers, it <b>must</b> create the dispatch
        table appropriately for all created dispatchable objects.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td>No</td>
    <td><small>
        <a href="#creating-new-dispatchable-objects">
          Creating New Dispatchable Objects</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_20</b></small></td>
    <td>A layer <b>must</b> remove all manifest files and references
        to those files (i.e. Registry entries on Windows) when uninstalling.
        <br/>
        Similarly, on updating the layer files, the old files <b>must</b> be all
        updated or removed.
    </td>
    <td>The loader ignores duplicate attempts to load the same manifest file,
        but if an old file is left pointing to an incorrect library, it will
        result in undefined behavior which may include crashes or corruption.
    </td>
    <td>No</td>
    <td>No<br/>
        The loader has no idea what layer files are new, old, or incorrect.
        Any type of layer file verification would quickly become very complex
        since it would require the loader to maintain an internal database
        tracking badly behaving layers based on the layer name, version,
        targeted platform(s), and possibly other criteria.
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td><small><b>LLP_LAYER_21</b></small></td>
    <td>During <i>vkCreateInstance</i>, a layer <b>must not</b> modify the
        <i>pInstance</i> pointer during prior to calling down to the lower
        layers.<br/>
        This is because the loader passes information in this pointer that is
        necessary for the initialization code in the loader's terminator
        function.<br/>
        Instead, if the layer is overriding the <i>pInstance</i> pointer, it
        <b>must</b> do so only after the call to the lower layers returns.
    </td>
    <td>The loader will likely crash.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
  <td><small><b>LLP_LAYER_22</b></small></td>
    <td>During <i>vkCreateDevice</i>, a layer <b>must not</b> modify the
        <i>pDevice</i> pointer during prior to calling down to the lower
        layers.<br/>
        This is because the loader passes information in this pointer that is
        necessary for the initialization code in the loader's terminator
        function.<br/>
        Instead, if the layer is overriding the <i>pDevice</i> pointer, it
        <b>must</b> do so only after the call to the lower layers returns.
    </td>
    <td>The loader will likely crash.</td>
    <td>No</td>
    <td>Yes</td>
    <td><small>N/A</small></td>
  </tr>
</table>

<h3 id="requirements-of-a-well-behaved-loader">Requirements of a Well-Behaved Loader</h3>
<table style="width:100%">
  <tr>
    <th>Requirement Number</th>
    <th>Requirement Description</th>
    <th>Result of Non-Compliance</th>
    <th>Applicable to Android?</th>
    <th>Reference Section</th>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_1</b></small></td>
    <td>A loader <b>must</b> support Vulkan layers.</td>
    <td>Users will not have access to critical parts of the Vulkan ecosystem
        such as Validation Layers, GfxReconstruct, or RenderDoc.</td>
    <td>Yes</td>
    <td><small>N/A</small></td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_2</b></small></td>
    <td>A loader <b>must</b> support a mechanism to load layers in one or
        more non-standard locations.<br/>
        This is to allow application/engine-specific layers as well as
        evaluating in-development layers without global installation.
    </td>
    <td>It will be more difficult to use a Vulkan loader by certain
        tools and driver developers.</td>
    <td>No</td>
    <td><small><a href="#layer-discovery">Layer Discovery</a></small></td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_3</b></small></td>
    <td>A loader <b>must</b> filter out duplicate layer names in the various
        enable lists, keeping only the first occurrence.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td><small><a href="#layer-discovery">Layer Discovery</a></small></td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_4</b></small></td>
    <td>A loader <b>must not</b> load a Vulkan layer which defines an
        API version that is incompatible with itself.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>Yes</td>
    <td><small><a href="#layer-discovery">Layer Discovery</a></small></td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_5</b></small></td>
    <td>A loader <b>must</b> ignore any layer for which a compatible interface
        version can not be negotiated.
    </td>
    <td>The loader would load a layer improperly resulting in undefined behavior
        which may include crashes or corruption.</td>
    <td>No</td>
    <td><small>
        <a href="#loader-and-layer-interface-negotiation">
        Interface Negotiation</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_6</b></small></td>
    <td>If a layer is implicit, and it has an enable environment variable,
        then a loader <b>must not</b> consider the layer enabled unless that
        enable environment variable is defined.<br/>
        If an implicit layer does not have an enable environment variable,
        it will be considered enabled by default.
    </td>
    <td>Some layers may be used when not intended.</td>
    <td>No</td>
    <td><small>
        <a href="#layer-manifest-file-format">Manifest File Format</a>, see
        "enable_environment" variable</small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_7</b></small></td>
    <td>If an implicit layer is enabled, but has been disabled by some other
        mechanism (such as the defining of the layer's disable environment
        variable or through the blacklisting mechanism of the Override Layer),
        then a loader <b>must not</b> load that layer.
    </td>
    <td>Some layers may be used when not intended.</td>
    <td>No</td>
    <td><small>
        <a href="#layer-manifest-file-format">Manifest File Format</a>, see
        "disable_environment" variable</small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_8</b></small></td>
    <td>A loader <b>must</b> pass a linked list of initialization structures
        to each layer via the <i>VkLayerInstanceCreateInfo</i> structure in the
        <i>pNext</i> field of the <i>VkInstanceCreateInfo</i> structure.
        This contains necessary information for setting up the instance call
        chain including providing a function pointer to the next links
        <i>vkGetInstanceProcAddr</i>.
    </td>
    <td>Layers will crash as they attempt to load invalid data.</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-dispatch-initialization">
           Layer Dispatch Initialization</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_9</b></small></td>
    <td>A loader <b>must</b> pass a linked list of initialization structures
        to each layer via the <i>VkLayerDeviceCreateInfo</i> structure in the
        <i>pNext</i> field of the <i>VkDeviceCreateInfo</i> structure.
        This contains necessary information for setting up the device call chain
        including providing a function pointer to the next links
        <i>vkGetDeviceProcAddr</i>.
    <td>Layers will crash as they attempt to load invalid data.</td>
    <td>Yes</td>
    <td><small>
        <a href="#layer-dispatch-initialization">
           Layer Dispatch Initialization</a>
        </small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_10</b></small></td>
    <td>A loader <b>must</b> verify that all meta-layers contain valid
        component layers that the loader can find on the system and that also
        report the same Vulkan API version as the meta-layer itself before it
        loads the meta-layer.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>No</td>
    <td><small>
        <a href="#meta-layers">Meta-Layers</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_11</b></small></td>
    <td>If the override meta-layer is present, a loader <b>must</b> load it
        and corresponding component layers after all other implicit layers have
        been added to the call chain.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>No</td>
    <td><small>
        <a href="#override-meta-layer">Override Meta-Layer</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_12</b></small></td>
    <td>If the override meta-layer is present and has a blacklist of layers to
        remove, a loader <b>must</b> disable all layers listed in the blacklist.
    </td>
    <td>The behavior is undefined and may result in crashes or corruption.</td>
    <td>No</td>
    <td><small>
        <a href="#override-meta-layer">Override Meta-Layer</a></small>
    </td>
  </tr>
  <tr>
    <td><small><b>LLP_LOADER_13</b></small></td>
    <td>A loader <b>must</b> not load from user-defined paths (including the
        use of <i>VK_LAYER_PATH</i>, <i>VK_ADD_LAYER_PATH</i>, <i>VK_IMPLICIT_LAYER_PATH</i>,
        or <i>VK_ADD_IMPLICIT_LAYER_PATH</i> environment variables) when running
        elevated (Administrator/Super-user) applications.<br/>
        <b>This is for security reasons.</b>
    </td>
    <td>The behavior is undefined and may result in computer security lapses,
        crashes or corruption.
    </td>
    <td>No</td>
    <td><small><a href="#layer-discovery">Layer Discovery</a></small></td>
  </tr>
</table>

<br/>

<p><a href="LoaderInterfaceArchitecture.html">Return to the top-level LoaderInterfaceArchitecture.html file.</a></p>
</article>
</body>
</html>
