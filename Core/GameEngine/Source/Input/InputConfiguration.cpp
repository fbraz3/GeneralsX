/*
**  Command & Conquer Generals Zero Hour(tm)
**  Copyright 2025 Electronic Arts Inc.
**
**  This program is free software: you can redistribute it and/or modify
**  it under the terms of the GNU General Public License as published by
**  the Free Software Foundation, either version 3 of the License, or
**  (at your option) any later version.
**
**  This program is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
**  GNU General Public License for more details.
**
**  You should have received a copy of the GNU General Public License
**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Input/InputConfiguration.h"
#include "Lib/BaseType.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

/*
**  Phase 47: Input Configuration Implementation
**  
**  Provides persistent input configuration with key rebinding support.
**  Stores configuration in INI format for easy editing and cross-platform compatibility.
*/

/* Maximum error message length */
#define MAX_ERROR_MSG 256

/* Static error buffer */
static char g_last_error[MAX_ERROR_MSG] = { 0 };

/* Profile directory */
#define PROFILES_DIR "Data/Input/Profiles"

/* Default profile values */
static const InputBinding DEFAULT_BINDINGS[ACTION_MAX_ACTIONS] = {
    /* ACTION_MOVE_UP */        { 0x48, 0x00, MODIFIER_NONE },  /* Up arrow */
    /* ACTION_MOVE_DOWN */      { 0x50, 0x00, MODIFIER_NONE },  /* Down arrow */
    /* ACTION_MOVE_LEFT */      { 0x4B, 0x00, MODIFIER_NONE },  /* Left arrow */
    /* ACTION_MOVE_RIGHT */     { 0x4D, 0x00, MODIFIER_NONE },  /* Right arrow */
    /* ACTION_SELECT_ALL */     { 0x1E, 0x00, MODIFIER_CTRL },  /* Ctrl+A */
    /* ACTION_ATTACK_MOVE */    { 0x02, 0x00, MODIFIER_NONE },  /* 1 */
    /* ACTION_STOP_UNITS */     { 0x0B, 0x00, MODIFIER_NONE },  /* 0 */
    /* ACTION_BUILD_MENU */     { 0x0E, 0x00, MODIFIER_NONE },  /* Backspace */
    /* ACTION_GENERAL_ABILITIES */ { 0x1C, 0x00, MODIFIER_NONE }, /* Enter */
    /* ACTION_CASH_BOUNTY */    { 0x2A, 0x00, MODIFIER_NONE },  /* Z */
    /* ACTION_REPLAY_PREVIOUS */{ 0x33, 0x00, MODIFIER_NONE },  /* , */
};

static const MouseConfiguration DEFAULT_MOUSE_CONFIG = {
    .sensitivity = 1.0f,
    .acceleration = 0.0f,
    .invert_y = FALSE,
    .raw_input = FALSE
};

static const GamepadConfiguration DEFAULT_GAMEPAD_CONFIG = {
    .analog_deadzone = 0.15f,
    .trigger_threshold = 0.5f,
    .stick_sensitivity = 1.0f,
    .button_mapping_enabled = TRUE
};

/* ============================================================================
 * Lifecycle Functions
 * ============================================================================ */

InputConfiguration* InputConfiguration_Create(void)
{
    InputConfiguration* config = (InputConfiguration*)malloc(sizeof(InputConfiguration));
    if (!config) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Failed to allocate InputConfiguration");
        return NULL;
    }

    memset(config, 0, sizeof(InputConfiguration));
    
    /* Set defaults */
    InputConfiguration_SetDefaults(config);
    
    printf("Phase 47: InputConfiguration created\n");
    return config;
}

void InputConfiguration_Destroy(InputConfiguration* config)
{
    if (!config) return;
    
    free(config);
    printf("Phase 47: InputConfiguration destroyed\n");
}

/* ============================================================================
 * File I/O Functions
 * ============================================================================ */

Bool InputConfiguration_LoadFromFile(InputConfiguration* config, const char* filename)
{
    if (!config || !filename) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    FILE* fp = fopen(filename, "r");
    if (!fp) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Cannot open file: %s", filename);
        printf("Phase 47: InputConfiguration - file not found, using defaults: %s\n", filename);
        return FALSE;
    }

    /* TODO: Implement INI parser for input configuration */
    /* For now, return FALSE to use defaults */
    fclose(fp);
    return FALSE;
}

Bool InputConfiguration_SaveToFile(InputConfiguration* config, const char* filename)
{
    if (!config || !filename) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    FILE* fp = fopen(filename, "w");
    if (!fp) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Cannot write file: %s", filename);
        return FALSE;
    }

    /* Write header */
    fprintf(fp, "; Command & Conquer Generals - Input Configuration\n");
    fprintf(fp, "; Auto-generated by Phase 47 InputConfiguration system\n\n");

    /* Write key bindings section */
    fprintf(fp, "[KeyBindings]\n");
    for (int i = 0; i < ACTION_MAX_ACTIONS; i++) {
        fprintf(fp, "action_%d_primary = 0x%X\n", i, config->key_bindings[i].primary_key);
        fprintf(fp, "action_%d_secondary = 0x%X\n", i, config->key_bindings[i].secondary_key);
        fprintf(fp, "action_%d_modifiers = 0x%X\n", i, config->key_bindings[i].modifier_flags);
    }

    /* Write mouse configuration section */
    fprintf(fp, "\n[Mouse]\n");
    fprintf(fp, "sensitivity = %f\n", config->mouse_config.sensitivity);
    fprintf(fp, "acceleration = %f\n", config->mouse_config.acceleration);
    fprintf(fp, "invert_y = %d\n", config->mouse_config.invert_y ? 1 : 0);
    fprintf(fp, "raw_input = %d\n", config->mouse_config.raw_input ? 1 : 0);

    /* Write gamepad configuration section */
    fprintf(fp, "\n[Gamepad]\n");
    fprintf(fp, "deadzone = %f\n", config->gamepad_config.analog_deadzone);
    fprintf(fp, "trigger_threshold = %f\n", config->gamepad_config.trigger_threshold);
    fprintf(fp, "stick_sensitivity = %f\n", config->gamepad_config.stick_sensitivity);
    fprintf(fp, "button_mapping = %d\n", config->gamepad_config.button_mapping_enabled ? 1 : 0);

    fclose(fp);
    printf("Phase 47: InputConfiguration saved to %s\n", filename);
    return TRUE;
}

Bool InputConfiguration_LoadProfile(InputConfiguration* config, const char* profile_name)
{
    if (!config || !profile_name) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    char filename[256];
    snprintf(filename, sizeof(filename), "%s/%s.ini", PROFILES_DIR, profile_name);
    
    Bool result = InputConfiguration_LoadFromFile(config, filename);
    if (result) {
        strncpy(config->profile_name, profile_name, sizeof(config->profile_name) - 1);
    }
    return result;
}

Bool InputConfiguration_SaveProfile(InputConfiguration* config, const char* profile_name)
{
    if (!config || !profile_name) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    char filename[256];
    snprintf(filename, sizeof(filename), "%s/%s.ini", PROFILES_DIR, profile_name);
    
    Bool result = InputConfiguration_SaveToFile(config, filename);
    if (result) {
        strncpy(config->profile_name, profile_name, sizeof(config->profile_name) - 1);
    }
    return result;
}

/* ============================================================================
 * Key Binding Management
 * ============================================================================ */

Bool InputConfiguration_SetKeyBinding(InputConfiguration* config, InputActionType action, 
                                      uint32_t key, uint32_t modifiers)
{
    if (!config || action >= ACTION_MAX_ACTIONS) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid action type: %d", action);
        return FALSE;
    }

    config->key_bindings[action].primary_key = key;
    config->key_bindings[action].modifier_flags = modifiers;
    
    printf("Phase 47: KeyBinding set - action:%d key:0x%X modifiers:0x%X\n", 
           action, key, modifiers);
    return TRUE;
}

Bool InputConfiguration_SetSecondaryKeyBinding(InputConfiguration* config, InputActionType action,
                                               uint32_t key, uint32_t modifiers)
{
    if (!config || action >= ACTION_MAX_ACTIONS) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid action type: %d", action);
        return FALSE;
    }

    config->key_bindings[action].secondary_key = key;
    /* Note: Secondary bindings share modifier flags with primary */
    
    printf("Phase 47: Secondary KeyBinding set - action:%d key:0x%X\n", action, key);
    return TRUE;
}

Bool InputConfiguration_GetKeyBinding(InputConfiguration* config, InputActionType action,
                                      uint32_t* out_key, uint32_t* out_modifiers)
{
    if (!config || action >= ACTION_MAX_ACTIONS || !out_key || !out_modifiers) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    *out_key = config->key_bindings[action].primary_key;
    *out_modifiers = config->key_bindings[action].modifier_flags;
    return TRUE;
}

Bool InputConfiguration_GetSecondaryKeyBinding(InputConfiguration* config, InputActionType action,
                                               uint32_t* out_key, uint32_t* out_modifiers)
{
    if (!config || action >= ACTION_MAX_ACTIONS || !out_key || !out_modifiers) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    *out_key = config->key_bindings[action].secondary_key;
    *out_modifiers = config->key_bindings[action].modifier_flags;
    return TRUE;
}

Bool InputConfiguration_ClearKeyBinding(InputConfiguration* config, InputActionType action)
{
    if (!config || action >= ACTION_MAX_ACTIONS) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid action type: %d", action);
        return FALSE;
    }

    config->key_bindings[action].primary_key = 0x00;
    config->key_bindings[action].secondary_key = 0x00;
    config->key_bindings[action].modifier_flags = MODIFIER_NONE;
    
    printf("Phase 47: KeyBinding cleared - action:%d\n", action);
    return TRUE;
}

InputActionType InputConfiguration_GetActionFromKey(InputConfiguration* config, 
                                                     uint32_t key, uint32_t modifiers)
{
    if (!config) return ACTION_MOVE_UP;  /* Return default action on error */

    for (int i = 0; i < ACTION_MAX_ACTIONS; i++) {
        if (config->key_bindings[i].primary_key == key && 
            config->key_bindings[i].modifier_flags == modifiers) {
            return (InputActionType)i;
        }
        if (config->key_bindings[i].secondary_key == key && 
            config->key_bindings[i].modifier_flags == modifiers) {
            return (InputActionType)i;
        }
    }

    return ACTION_MOVE_UP;  /* No action found, return default */
}

/* ============================================================================
 * Mouse Configuration
 * ============================================================================ */

void InputConfiguration_SetMouseSensitivity(InputConfiguration* config, float sensitivity)
{
    if (!config) return;
    
    if (sensitivity < 0.1f) sensitivity = 0.1f;
    if (sensitivity > 2.0f) sensitivity = 2.0f;
    
    config->mouse_config.sensitivity = sensitivity;
    printf("Phase 47: Mouse sensitivity set to %.2f\n", sensitivity);
}

float InputConfiguration_GetMouseSensitivity(InputConfiguration* config)
{
    if (!config) return 1.0f;
    return config->mouse_config.sensitivity;
}

void InputConfiguration_SetMouseAcceleration(InputConfiguration* config, float acceleration)
{
    if (!config) return;
    
    if (acceleration < 0.0f) acceleration = 0.0f;
    if (acceleration > 1.0f) acceleration = 1.0f;
    
    config->mouse_config.acceleration = acceleration;
    printf("Phase 47: Mouse acceleration set to %.2f\n", acceleration);
}

void InputConfiguration_SetMouseInvertY(InputConfiguration* config, Bool invert)
{
    if (!config) return;
    config->mouse_config.invert_y = invert;
    printf("Phase 47: Mouse invert Y set to %d\n", invert);
}

/* ============================================================================
 * Gamepad Configuration
 * ============================================================================ */

void InputConfiguration_SetGamepadDeadzone(InputConfiguration* config, float deadzone)
{
    if (!config) return;
    
    if (deadzone < 0.0f) deadzone = 0.0f;
    if (deadzone > 0.5f) deadzone = 0.5f;
    
    config->gamepad_config.analog_deadzone = deadzone;
    printf("Phase 47: Gamepad deadzone set to %.2f\n", deadzone);
}

float InputConfiguration_GetGamepadDeadzone(InputConfiguration* config)
{
    if (!config) return 0.15f;
    return config->gamepad_config.analog_deadzone;
}

void InputConfiguration_SetGamepadSensitivity(InputConfiguration* config, float sensitivity)
{
    if (!config) return;
    
    if (sensitivity < 0.5f) sensitivity = 0.5f;
    if (sensitivity > 2.0f) sensitivity = 2.0f;
    
    config->gamepad_config.stick_sensitivity = sensitivity;
    printf("Phase 47: Gamepad sensitivity set to %.2f\n", sensitivity);
}

/* ============================================================================
 * Profile Management (Stub - Ready for INI implementation)
 * ============================================================================ */

Bool InputConfiguration_ListProfiles(const char*** out_profiles, int* out_count)
{
    if (!out_profiles || !out_count) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid parameters");
        return FALSE;
    }

    /* TODO: Implement directory scanning for .ini files in PROFILES_DIR */
    *out_profiles = NULL;
    *out_count = 0;
    printf("Phase 47: Profile listing stub - implement with INI parser\n");
    return FALSE;
}

Bool InputConfiguration_CreateProfile(const char* name)
{
    if (!name) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Profile name is NULL");
        return FALSE;
    }

    printf("Phase 47: Profile creation stub - %s - implement with INI writer\n", name);
    return FALSE;
}

Bool InputConfiguration_DeleteProfile(const char* name)
{
    if (!name) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Profile name is NULL");
        return FALSE;
    }

    printf("Phase 47: Profile deletion stub - %s - implement with file system\n", name);
    return FALSE;
}

Bool InputConfiguration_RenameProfile(const char* old_name, const char* new_name)
{
    if (!old_name || !new_name) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid profile names");
        return FALSE;
    }

    printf("Phase 47: Profile rename stub - %s -> %s - implement with file system\n", old_name, new_name);
    return FALSE;
}

/* ============================================================================
 * Default Configuration
 * ============================================================================ */

void InputConfiguration_SetDefaults(InputConfiguration* config)
{
    if (!config) return;

    memcpy(config->key_bindings, DEFAULT_BINDINGS, sizeof(DEFAULT_BINDINGS));
    config->mouse_config = DEFAULT_MOUSE_CONFIG;
    config->gamepad_config = DEFAULT_GAMEPAD_CONFIG;
    strncpy(config->profile_name, "Default", sizeof(config->profile_name) - 1);
    config->auto_save_enabled = FALSE;
    
    printf("Phase 47: InputConfiguration defaults set\n");
}

void InputConfiguration_ResetToDefaults(InputConfiguration* config)
{
    InputConfiguration_SetDefaults(config);
}

/* ============================================================================
 * Validation
 * ============================================================================ */

Bool InputConfiguration_IsValid(InputConfiguration* config)
{
    if (!config) return FALSE;

    /* Check basic constraints */
    if (config->mouse_config.sensitivity < 0.1f || config->mouse_config.sensitivity > 2.0f) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid mouse sensitivity");
        return FALSE;
    }

    if (config->gamepad_config.analog_deadzone < 0.0f || 
        config->gamepad_config.analog_deadzone > 0.5f) {
        snprintf(g_last_error, MAX_ERROR_MSG, "Invalid gamepad deadzone");
        return FALSE;
    }

    return TRUE;
}

const char* InputConfiguration_GetLastError(void)
{
    return g_last_error;
}
