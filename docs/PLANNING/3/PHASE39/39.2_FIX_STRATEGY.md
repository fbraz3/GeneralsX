# Phase 39.2: Fix Strategy & Implementation Plan

**Date**: 2025-11-16  
**Philosophy**: Fail-Fast, Root-Cause Analysis, No Empty Stubs  
**Target**: Zero compilation errors with SDL2 equivalents for all Win32 APIs

## Part 1: Critical Stubs to Fix (msvc_types_compat.h)

These are the highest priority - they're incomplete and must be replaced with SDL2:

### 1.1 Threading Primitives - CRITICAL

**File**: `/Dependencies/Utility/Compat/msvc_types_compat.h`

#### Current (BROKEN):
```cpp
// Line 114 - CreateEvent stub - returns dummy handle
inline HANDLE CreateEvent(...) {
    static int dummy_handle = 0xDEADBEEF;
    return (HANDLE)&dummy_handle;  // ❌ Non-functional!
}
```

#### Fix: Use SDL2 Mutexes
```cpp
#include <SDL2/SDL.h>

typedef struct {
    SDL_mutex* mutex;
    int signaled;
} SDL2_Event;

inline HANDLE CreateEvent(void* lpEventAttributes, int bManualReset, 
                         int bInitialState, const char* lpName) {
    SDL2_Event* evt = new SDL2_Event();
    evt->mutex = SDL_CreateMutex();
    evt->signaled = bInitialState ? 1 : 0;
    return (HANDLE)evt;
}

inline BOOL SetEvent(HANDLE hEvent) {
    if (!hEvent) return FALSE;
    SDL2_Event* evt = (SDL2_Event*)hEvent;
    SDL_LockMutex(evt->mutex);
    evt->signaled = 1;
    SDL_UnlockMutex(evt->mutex);
    return TRUE;
}

inline BOOL ResetEvent(HANDLE hEvent) {
    if (!hEvent) return FALSE;
    SDL2_Event* evt = (SDL2_Event*)hEvent;
    SDL_LockMutex(evt->mutex);
    evt->signaled = 0;
    SDL_UnlockMutex(evt->mutex);
    return TRUE;
}

inline DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds) {
    if (!hHandle) return WAIT_FAILED;
    SDL2_Event* evt = (SDL2_Event*)hHandle;
    
    SDL_LockMutex(evt->mutex);
    if (evt->signaled) {
        SDL_UnlockMutex(evt->mutex);
        return WAIT_OBJECT_0;
    }
    SDL_UnlockMutex(evt->mutex);
    
    // Simple polling approach (not ideal, but cross-platform)
    int elapsed = 0;
    while (elapsed < (int)dwMilliseconds) {
        SDL_LockMutex(evt->mutex);
        if (evt->signaled) {
            SDL_UnlockMutex(evt->mutex);
            return WAIT_OBJECT_0;
        }
        SDL_UnlockMutex(evt->mutex);
        SDL_Delay(10);
        elapsed += 10;
    }
    return WAIT_TIMEOUT;
}
```

#### Why:
- Original returns dummy handle that breaks any code checking the value
- SDL2 provides portable mutex implementation
- Fixes: Any code using WaitForSingleObject on events

---

### 1.2 System Time - MEDIUM Priority

**File**: `/Dependencies/Utility/Compat/msvc_types_compat.h`

#### Current (Incomplete):
```cpp
// Line 122 - GetDoubleClickTime stub
inline unsigned int GetDoubleClickTime() {
    return 500;  // Hardcoded!
}

// Line 128 - GetLocalTime stub - incomplete
inline void GetLocalTime(SYSTEMTIME* lpSystemTime) {
    if (!lpSystemTime) return;
    time_t now = time(NULL);
    struct tm* localtime_result = localtime(&now);
    // ... fills SYSTEMTIME
}
```

#### Fix: Use SDL2 Timing
```cpp
// GetTickCount - already mapped to SDL_GetTicks in modern SDL2
#include <SDL2/SDL.h>

inline DWORD GetTickCount() {
    return (DWORD)SDL_GetTicks();  // ✅ Portable millisecond timer
}

inline DWORD GetTickCount64() {
    return (DWORD)SDL_GetTicksMS();  // ✅ 64-bit ticks (SDL 2.26+)
}

// GetDoubleClickTime - use SDL2 to query system settings
// On non-Windows, use reasonable default based on platform
inline unsigned int GetDoubleClickTime() {
    #ifdef _WIN32
        return ::GetDoubleClickTime();  // Windows native
    #else
        // SDL2 doesn't expose this, use reasonable cross-platform default
        // Most systems use 300-500ms, macOS typically 400ms
        return 400;
    #endif
}
```

#### Why:
- GetTickCount hardcoded is fine, but GetTickCount64 missing causes issues on 64-bit code
- SDL_GetTicks is portable and used throughout the codebase
- Fixes: Timing-related crashes in game logic

---

### 1.3 Module Path - HIGH Priority

**File**: `/Dependencies/Utility/Compat/msvc_types_compat.h`

#### Current (Broken):
```cpp
// Line 180 - GetModuleFileName stub
inline DWORD GetModuleFileName(HMODULE hModule, LPSTR lpFilename, DWORD nSize) {
    // STUB - NOT IMPLEMENTED
    if (lpFilename && nSize > 0) {
        lpFilename[0] = '\0';
    }
    return 0;
}
```

#### Fix: Use POSIX + SDL2
```cpp
#include <unistd.h>
#include <mach-o/dyld.h>  // macOS
#include <libgen.h>        // dirname

inline DWORD GetModuleFileName(HMODULE hModule, LPSTR lpFilename, DWORD nSize) {
    if (!lpFilename || nSize == 0) return 0;

    #ifdef _WIN32
        return ::GetModuleFileName(hModule, lpFilename, nSize);
    #elif __APPLE__
        // macOS implementation
        uint32_t bufsize = nSize;
        if (_NSGetExecutablePath(lpFilename, &bufsize) == 0) {
            return strlen(lpFilename);
        }
        return 0;
    #else
        // Linux implementation
        ssize_t len = readlink("/proc/self/exe", lpFilename, nSize - 1);
        if (len > 0) {
            lpFilename[len] = '\0';
            return len;
        }
        return 0;
    #endif
}
```

#### Why:
- Game needs executable path for asset loading
- Current stub returns empty string → asset paths broken on macOS/Linux
- POSIX APIs are reliable and standard
- Fixes: Asset loading failures on non-Windows

---

## Part 2: Win32 API to SDL2 Mapping (In-Code)

These are in actual game code and need SDL2 wrappers:

### 2.1 GetAsyncKeyState → SDL_GetKeyboardState

**Files**: `W3DWaterTracks.cpp` (6 instances)

#### Current:
```cpp
if (GetAsyncKeyState(VK_F5) & 0x8001)  // Check if F5 pressed
```

#### Fix Strategy:
```cpp
// Create cross-platform key state function
#include <SDL2/SDL.h>

inline bool IsKeyPressed(int key) {
    #ifdef _WIN32
        return (::GetAsyncKeyState(key) & 0x8001) != 0;
    #else
        const Uint8* keystate = SDL_GetKeyboardState(NULL);
        SDL_Scancode scancode = SDL_GetScancodeFromKey(key);
        return keystate[scancode] != 0;
    #endif
}

// Then replace:
// OLD: if (GetAsyncKeyState(VK_F5) & 0x8001)
// NEW: if (IsKeyPressed(SDLK_F5))
```

#### Why:
- GetAsyncKeyState only works on Windows
- SDL_GetKeyboardState is portable
- VK_* constants don't exist on macOS/Linux
- Fixes: Input handling on non-Windows

---

### 2.2 CriticalSection → SDL_mutex

**Files**:
- `GeneralsMD/Code/GameEngine/Include/Common/CriticalSection.h`
- `GeneralsMD/Code/Main/WinMain.cpp` (5x static instances)
- `W3DMouse.cpp` (CriticalSectionClass usage)

#### Current Pattern:
```cpp
// Windows-only
#ifdef _WIN32
    InitializeCriticalSection(&cs);
    EnterCriticalSection(&cs);
    // Critical code
    LeaveCriticalSection(&cs);
    DeleteCriticalSection(&cs);
#else
    // Empty stubs!
#endif
```

#### Fix: Use SDL2 Mutexes Everywhere
```cpp
// In CriticalSection.h - make it SDL2-based
#include <SDL2/SDL.h>

class CriticalSection {
private:
    SDL_mutex* m_mutex;
    
public:
    CriticalSection() : m_mutex(SDL_CreateMutex()) {}
    ~CriticalSection() { if (m_mutex) SDL_DestroyMutex(m_mutex); }
    
    void Enter() { SDL_LockMutex(m_mutex); }
    void Leave() { SDL_UnlockMutex(m_mutex); }
};

// RAII wrapper (no longer Windows-specific)
class ScopedCriticalSection {
private:
    CriticalSection* m_cs;
public:
    ScopedCriticalSection(CriticalSection* cs) : m_cs(cs) { 
        if (m_cs) m_cs->Enter(); 
    }
    ~ScopedCriticalSection() { 
        if (m_cs) m_cs->Leave(); 
    }
};
```

#### Why:
- CriticalSection stubs do nothing on macOS/Linux → race conditions
- SDL_mutex is portable and efficient
- Already used for HWND abstraction, why not threading?
- Fixes: Thread safety across all platforms

---

## Part 3: Missing POSIX Implementations

These need platform-specific implementations:

### 3.1 File Operations

**Issue**: Game uses `GetModuleFileName` for asset paths but doesn't handle macOS/Linux

**Fix**: Already covered above (1.3)

### 3.2 Directory Creation

**Current**:
```cpp
// Line 173 - CreateDirectory stub
inline BOOL CreateDirectory(const char* lpPathName, void* lpSecurityAttributes) {
    return mkdir(lpPathName, 0755) == 0;  // Incomplete - doesn't handle parents
}
```

**Fix**:
```cpp
inline BOOL CreateDirectory(const char* lpPathName, void* lpSecurityAttributes) {
    #ifdef _WIN32
        return ::CreateDirectory(lpPathName, (LPSECURITY_ATTRIBUTES)lpSecurityAttributes);
    #else
        // Create directory with parents if needed
        char* path_copy = strdup(lpPathName);
        char* p = path_copy + 1;
        while (*p) {
            if (*p == '/') {
                *p = '\0';
                mkdir(path_copy, 0755);  // Ignore error if exists
                *p = '/';
            }
            p++;
        }
        int result = mkdir(path_copy, 0755);
        free(path_copy);
        return result == 0 || errno == EEXIST;
    #endif
}
```

---

## Implementation Order (Fail-Fast Priority)

1. **Highest**: Fix threading stubs (CreateEvent, WaitForSingleObject) - used in initialization
2. **High**: Fix GetModuleFileName - asset loading broken without it
3. **High**: Fix GetTickCount - timing issues
4. **Medium**: Fix GetAsyncKeyState - input handling
5. **Medium**: Fix CriticalSection - thread safety
6. **Low**: Fix MessageBox, DLL stubs - rarely used in game core

---

## Validation Strategy

After each fix:
1. Recompile incrementally: `cmake --build build/macos-arm64-vulkan -j 4 2>&1 | tee logs/phase39_2_build.log`
2. Check for new errors: `grep "error:" logs/phase39_2_build.log`
3. If no new errors → move to next fix
4. If new errors → investigate root cause (fail-fast!)

---

## Expected Outcome

✅ All 100+ stubs replaced with SDL2/POSIX equivalents  
✅ No empty stubs remaining  
✅ All Win32 APIs have platform-equivalent implementations  
✅ Zero compilation errors on macOS ARM64  
✅ Game builds and runs with proper cross-platform support

---

## Notes

- DO NOT use `#ifdef _WIN32` as first solution - always ask "what does this DO?" first
- DO NOT leave stubs - every API needs a working implementation
- DO NOT assume Linux = macOS - both need separate implementations sometimes
- DO use SDL2 when available - it's already a dependency
- DO test each fix incrementally
