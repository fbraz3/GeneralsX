<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="icon" href="images/Vulkan_LogoBug_48px_Nov17.png">
<link rel="stylesheet" href="github-markdown.css">
</head>
<body>
<article class="markdown-body">
<!-- markdownlint-disable MD033 -->

<!-- markdownlint-disable MD041 -->

<p align="left"><img src="https://vulkan.lunarg.com/img/NewLunarGLogoBlack.png" alt="LunarG" width=263 height=113 /></p>

<p><a href="https://creativecommons.org/licenses/by-nd/4.0/" TARGET="_blank"><img src="https://i.creativecommons.org/l/by-nd/4.0/88x31.png" title="Creative Commons License" alt="Creative Commons" /></a></p>
<p>Copyright © 2018-2022 LunarG, Inc.</p>
<p>Copyright © 2022 Advanced Micro Devices, Inc.</p>
<h1 id="gfxreconstruct-api-capture-and-replay---vulkan">GFXReconstruct API Capture and Replay - Vulkan</h1>
<p><em><strong>This document describes the GFXReconstruct software for capturing and replaying Vulkan API calls on Desktop systems (i.e. Windows, Linux, MacOS).</strong></em></p>
<p>If you are looking for capturing/replaying on a different platform, please refer to one of these other documents:</p>
<ul>
<li><a href="./USAGE_android.html">GfxReconstruct for Android</a></li>
<li><a href="./USAGE_desktop_D3D12.html">GfxReconstruct for Desktop D3D12</a></li>
</ul>
<h2 id="index">Index</h2>
<ol>
<li><a href="#capturing-api-calls">Capturing API calls</a>
<ol>
<li><a href="#enabling-the-capture-layer">Enabling the Capture Layer</a></li>
<li><a href="#capture-options">Capture Options</a></li>
<li><a href="#capture-files">Capture Files</a></li>
<li><a href="#capture-script">Capture Script</a></li>
</ol></li>
<li><a href="#replaying-api-calls">Replaying API Calls</a>
<ol>
<li><a href="#command-line-arguments">Command Line Arguments</a></li>
<li><a href="#key-controls">Key Controls</a></li>
<li><a href="#virtual-swapchain">Virtual Swapchain</a></li>
<li><a href="#dumping-resources">Dumping resources</a></li>
</ol></li>
<li><a href="#other-capture-file-processing-tools">Other Capture File Processing Tools</a>
<ol>
<li><a href="#capture-file-info">Capture File Info</a></li>
<li><a href="#capture-file-compression">Capture File Compression</a></li>
<li><a href="#shader-extraction">Shader Extraction</a></li>
<li><a href="#trimmed-file-optimization">Trimmed File Optimization</a></li>
<li><a href="#json-lines-conversion">JSON Lines Conversion</a></li>
<li><a href="#command-launcher">Command Launcher</a></li>
<li><a href="#common-options">Options Common To All Tools</a></li>
</ol></li>
</ol>
<h2 id="capturing-api-calls">Capturing API calls</h2>
<p>The GFXReconstruct capture layer is a Vulkan layer that intercepts Vulkan API calls and logs them to a GFXReconstruct capture file.</p>
<h3 id="enabling-the-capture-layer">Enabling the Capture Layer</h3>
<p>The path to the layer's <code>VkLayer_gfxreconstruct.json</code> file and corresponding <code>VkLayer_gfxreconstruct</code> library must be added to <code>VK_LAYER_PATH</code> environment variable for the Vulkan loader to find the layer.</p>
<p>After <code>VK_LAYER_PATH</code> has been updated, the layer may be enabled through one of the following methods:</p>
<ul>
<li>Adding the <code>VK_LAYER_LUNARG_gfxreconstruct</code> name string to the <code>VkInstanceCreateInfo::ppEnabledLayerNames</code> value when calling <code>vkCreateInstance</code></li>
<li>Adding the <code>VK_LAYER_LUNARG_gfxreconstruct</code> name string to the list of layer names specified through the <code>VK_INSTANCE_LAYERS</code> environment variable</li>
</ul>
<h4 id="setting-vk_layer_path">Setting VK_LAYER_PATH</h4>
<p>The <code>VK_LAYER_PATH</code> environment variable can be used to tell the Vulkan loader where to find the GFXReconstruct capture layer. If you are using GFXReconstruct from a Vulkan SDK installation or a Linux package install, there is no need to set VK_LAYER_PATH - the installation process will have set up the GFXReconstruct capture layer so that the Vulkan loader can find and load it.</p>
<h5 id="setting-vk_layer_path-for-windows">Setting VK_LAYER_PATH for Windows</h5>
<p>If you are not using GFXReconstruct from a Vulkan SDK, use the following as an example of how to update the Windows <code>VK_LAYER_PATH</code> environment variable for the GFXReconstruct capture layer. The example uses the <code>C:\gfxreconstruct</code> path to represent the location of directory containing the GFXReconstruct project source, and the <code>build</code> folder name to represent the sub-directory specified to CMake as the location to place the build binaries. The following command would be executed from the command prompt to add the Debug build of the layer to <code>VK_LAYER_PATH</code>:</p>
<pre class="bat"><code>set VK_LAYER_PATH=C:\gfxreconstruct\build\layer\Debug;%VK_LAYER_PATH%
</code></pre>
<h5 id="setting-vk_layer_path-for-linux">Setting VK_LAYER_PATH for Linux</h5>
<p>If you are not using GFXReconstruct from the Vulkan SDK or a Linux package, use the following as an example of how to update the Linux <code>VK_LAYER_PATH</code> environment variable for the GFXReconstruct capture layer. The example uses the <code>/gfxreconstruct</code> path to represent the location of directory containing the GFXReconstruct project source, and the <code>build</code> folder name to represent the sub-directory specified to CMake as the location to place the build binaries. The following command would be executed from the command line to add the layer to <code>VK_LAYER_PATH</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="bu">export</span> <span class="va">VK_LAYER_PATH=</span>/gfxreconstruct/build/layer:<span class="va">$VK_LAYER_PATH</span></a></code></pre></div>
<h4 id="enabling-the-layer-with-vk_instance_layers">Enabling the layer with VK_INSTANCE_LAYERS</h4>
<p>The <code>VK_INSTANCE_LAYERS</code> environment variable may be used so that the the GFXReconstruct layer is loaded by the Vulkan loader.</p>
<h5 id="enabling-the-layer-for-windows">Enabling the layer for Windows</h5>
<p>The following command would be executed from the command prompt to set the <code>VK_INSTANCE_LAYERS</code> environment variable:</p>
<pre class="bat"><code>set VK_INSTANCE_LAYERS=VK_LAYER_LUNARG_gfxreconstruct
</code></pre>
<h5 id="enabling-the-layer-for-linux">Enabling the layer for Linux</h5>
<p>The following command would be executed from the command line to set the <code>VK_INSTANCE_LAYERS</code> environment variable:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="bu">export</span> <span class="va">VK_INSTANCE_LAYERS=</span>VK_LAYER_LUNARG_gfxreconstruct</a></code></pre></div>
<h4 id="capture-specific-app">Capture specific app</h4>
<h5 id="capture-specific-app-for-windows">Capture specific app for Windows</h5>
<p>set GFXRECON_CAPTURE_PROCESS_NAME=your_app_name</p>
<h5 id="capture-specific-app-for-linux">Capture specific app for Linux</h5>
<p>export GFXRECON_CAPTURE_PROCESS_NAME=your_app_name</p>
<h4 id="understanding-gfxreconstruct-layer-memory-capture">Understanding GFXReconstruct Layer Memory Capture</h4>
<p>The Vulkan API allows Vulkan memory objects to be mapped by an application for direct modification. To successfully capture an application, the GFXReconstruct layer must be able to detect if the application modifies the mapped memory in order to dump the changes in the capture file so that they can be re-applied while replaying. To achieve this GFXR utilizes four different modes:</p>
<h5 id="1-assisted">1. <code>assisted</code></h5>
<p>This mode expects the application to call <code>vkFlushMappedMemoryRanges</code> after memory is modified; the memory ranges specified to the <code>vkFlushMappedMemoryRanges</code> call will be written to the capture file during the call.</p>
<h5 id="2-unassisted">2. <code>unassisted</code></h5>
<p>This mode writes the full content of mapped memory to the capture file on calls to <code>vkUnmapMemory</code> and <code>vkQueueSubmit</code>. It is very inefficient for performance and it will bloat capture file sizes. May be unusable with real-world applications that map large amounts of memory.</p>
<h5 id="3-page_guard">3. <code>page_guard</code></h5>
<p><code>page_guard</code> tracks modifications to individual memory pages, which are written to the capture file on calls to <code>vkFlushMappedMemoryRanges</code>, <code>vkUnmapMemory</code>, and <code>vkQueueSubmit</code>. This method requires allocating shadow memory for all mapped memory. The way the changes are being tracked varies depending on the operating system.</p>
<ul>
<li>On Windows <code>Vectored Exception Handling</code> mechanism is used on the shadow memories that correspond to the mapped device memory regions.</li>
<li>On Linux and Android the shadow memory regions are similarly trapped by changing its access protection to <code>PROT_NONE</code>. Every access from the application will generate a <code>SIGSEGV</code> which is handled by the appropriate signal handler installed by the page guard manager.</li>
</ul>
<p>Because a shadow memory is allocated and returned to the application instead of the actual mapped memory returned by the driver, both reads and writes need to be tracked.</p>
<ul>
<li>Writes need to be dumped to the capture file.</li>
<li>Reads must trigger a memory copy from the actual mapped memory into the shadow memory so that the application will read the correct/updated data each time.</li>
</ul>
<p><code>page_guard</code> is the most efficient, both performance and capture file size wise, mechanism. However, as described in <a href="#conflicts-with-crash-detection-libraries">Conflicts With Crash Detection Libraries</a>, it has some limitation when capturing applications that install their own signal handler for handling the <code>SIGSEGV</code> signal. This limitation exists only on Linux and Android applications. To work around this limitation there is the <code>userfaultfd</code> mechanism.</p>
<h5 id="4-userfaultfd">4. <code>userfaultfd</code></h5>
<p>This mode utilizes the userfaultfd mechanism provided by the Linux kernel which allows user space applications to detect and handle page faults. Under the hood <code>userfaultfd</code> is the same mechanism as <code>page_guard</code> but instead of trapping the shadow memory regions with the <code>PROT_NONE</code> + <code>SIGSEGV</code> trick, it registers those memory regions for tracking to the userfaultfd mechanism.</p>
<p>Shadow memory regions are registered using the <code>UFFDIO_REGISTER_MODE_WP | UFFDIO_REGISTER_MODE_MISSING</code> flags with the userfaultfd mechanism and a handler thread is started and polls for faults to trigger. The combination of those flags will trigger a fault in two cases:</p>
<ul>
<li>When an unallocated page is accessed with either a write or a read.</li>
<li>When a page is written.</li>
</ul>
<p>This imposes a limitation: When the shadow memory is freshly allocated all pages will be unallocated, making tracking both reads and writes simple as both will trigger a fault. However, after the first time the accesses are tracked and dumped to the capture file, the reads cannot be tracked any longer as the pages will be already allocated and won't trigger a fault. To workaround this each time the memory is examined, the dirty regions are being "reset". This involves unregistering those subregions from userfaultfd, requesting new pages from the OS to be provided at the same virtual addresses and then the subregions are registered again for tracking. This has a performance penalty as in this case both reads and writes need to be copied from the actual mapped memory into the shadow memory when detected, while the <code>page_guard</code> method requires this only for reads.</p>
<p>Also there is another limitation. The way the new pages are requested each time and the regions are unregistered and registered again, makes this mechanism prone to race conditions when there are multiple threads. If a thread is accessing a specific page within a region and at the same time that region is being reset, then the access is not trapped and undefined behavior occurs.</p>
<p>In order to work around this a list of the thread ids that access each region is kept. When that specific region is being reset a signal is sent to each thread which will force them to enter a signal handler that GFXR registers for that signal. The signal handler essentially performs a form of synchronization between the thread that is triggering the reset and the rest of the threads that potentially are touching pages that are being reset. The signal used one of the real time signals, the first in the range [<code>SIGRTMIN</code>, <code>SIGRTMAX</code>] that has no handler already installed.</p>
<p><code>userfaultfd</code> is less efficient performance wise than <code>page_guard</code> but should be fast enough for real-world applications and games.</p>
<h5 id="disabling-debug-breaks-triggered-by-the-gfxreconstruct-layer">Disabling Debug Breaks Triggered by the GFXReconstruct Layer</h5>
<p>When running an application in a debugger with the layer enabled, the access violations triggered by the layer's memory tracking behavior may cause the debugger to break. For example, on macOS using LLDB, these debug breaks may be disabled with the following command:</p>
<pre class="text"><code>process handle SIGSEGV -n true -p true -s false
</code></pre>
<p>The equivalent command for GDB is:</p>
<pre class="text"><code>handle SIGSEGV nostop noprint
</code></pre>
<h3 id="capture-options">Capture Options</h3>
<p>The GFXReconstruct layer supports several options, which may be enabled through environment variables or a layer settings file.</p>
<h4 id="windows-options">Windows Options</h4>
<p>The following example demonstrates how to set the layer's log level to "warning" from the Windows command prompt:</p>
<pre class="bat"><code>set GFXRECON_LOG_LEVEL=warning
</code></pre>
<h4 id="linux-options">Linux Options</h4>
<p>The following example demonstrates how to set the layer's log level to "warning" from the Linux command line:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="bu">export</span> <span class="va">GFXRECON_LOG_LEVEL=</span>warning</a></code></pre></div>
<h4 id="supported-options">Supported Options</h4>
<p>Options with the BOOL type accept the following values:</p>
<ul>
<li>A case-insensitive string value 'true' or a non-zero integer value indicate true.</li>
<li>A case-insensitive string value 'false' or a zero integer value indicate false.</li>
</ul>
<p>The capture layer will generate a warning message for unrecognized or invalid option values.</p>
<table>
<thead>
<tr class="header">
<th>Option</th>
<th>Environment Variable</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Capture File Name</td>
<td>GFXRECON_CAPTURE_FILE</td>
<td>STRING</td>
<td>Path to use when creating the capture file. Supports variable patterns for dynamic file paths, such as <code>${AppName}</code> (the application or executable name). Default is: <code>gfxrecon_capture.gfxr</code></td>
</tr>
<tr class="even">
<td>Capture Specific Frames</td>
<td>GFXRECON_CAPTURE_FRAMES</td>
<td>STRING</td>
<td>Specify one or more comma-separated frame ranges to capture. Each range will be written to its own file. A frame range can be specified as a single value, to specify a single frame to capture, or as two hyphenated values, to specify the first and last frame to capture. Frame ranges should be specified in ascending order and cannot overlap. Note that frame numbering is 1-based (i.e. the first frame is frame 1). Example: <code>200,301-305</code> will create two capture files, one containing a single frame and one containing five frames. Default is: Empty string (all frames are captured).</td>
</tr>
<tr class="odd">
<td>Capture specific app</td>
<td>GFXRECON_CAPTURE_PROCESS_NAME</td>
<td>STRING</td>
<td>Specify one app name to be captured. Default is: ""</td>
</tr>
<tr class="even">
<td>Quit after capturing frame ranges</td>
<td>GFXRECON_QUIT_AFTER_CAPTURE_FRAMES</td>
<td>BOOL</td>
<td>Setting it to <code>true</code> will force the application to terminate once all frame ranges specified by <code>GFXRECON_CAPTURE_FRAMES</code> have been captured. Default is: <code>false</code></td>
</tr>
<tr class="odd">
<td>Hotkey Capture Trigger</td>
<td>GFXRECON_CAPTURE_TRIGGER</td>
<td>STRING</td>
<td>Specify a hotkey (any one of F1-F12, TAB, CONTROL) that will be used to start/stop capture. Example: <code>F3</code> will set the capture trigger to F3 hotkey. One capture file will be generated for each pair of start/stop hotkey presses. Default is: Empty string (hotkey capture trigger is disabled).</td>
</tr>
<tr class="even">
<td>Hotkey Capture Trigger Frames</td>
<td>GFXRECON_CAPTURE_TRIGGER_FRAMES</td>
<td>STRING</td>
<td>Specify a limit on the number of frames to be captured via hotkey. Example: <code>1</code> will capture exactly one frame when the trigger key is pressed. Default is: Empty string (no limit)</td>
</tr>
<tr class="odd">
<td>Use asset file</td>
<td>GFXRECON_CAPTURE_USE_ASSET_FILE</td>
<td>BOOL</td>
<td>When set to <code>true</code> assets (images, buffers and descriptors) will be stored separately into an asset file instead of the capture file.</td>
</tr>
<tr class="even">
<td>Capture Specific GPU Queue Submits</td>
<td>GFXRECON_CAPTURE_QUEUE_SUBMITS</td>
<td>STRING</td>
<td>Specify one or more comma-separated GPU queue submit call ranges to capture. Queue submit calls are <code>vkQueueSubmit</code> for Vulkan and <code>ID3D12CommandQueue::ExecuteCommandLists</code> for DX12. Queue submit ranges work as described above in <code>GFXRECON_CAPTURE_FRAMES</code> but on GPU queue submit calls instead of frames. The index is 0-based. Default is: Empty string (all queue submits are captured).</td>
</tr>
<tr class="odd">
<td>Capture File Compression Type</td>
<td>GFXRECON_CAPTURE_COMPRESSION_TYPE</td>
<td>STRING</td>
<td>Compression format to use with the capture file. Valid values are: <code>LZ4</code>, <code>ZLIB</code>, <code>ZSTD</code>, and <code>NONE</code>. Default is: <code>LZ4</code></td>
</tr>
<tr class="even">
<td>Capture File Timestamp</td>
<td>GFXRECON_CAPTURE_FILE_TIMESTAMP</td>
<td>BOOL</td>
<td>Add a timestamp to the capture file as described by <a href="#timestamps">Timestamps</a>. Default is: <code>true</code></td>
</tr>
<tr class="odd">
<td>Capture File Flush After Write</td>
<td>GFXRECON_CAPTURE_FILE_FLUSH</td>
<td>BOOL</td>
<td>Flush output stream after each packet is written to the capture file. Default is: <code>false</code></td>
</tr>
<tr class="even">
<td>Capture Environment</td>
<td>GFXRECON_CAPTURE_ENVIRONMENT</td>
<td>STRING</td>
<td>Comma delimited list of environment variables to store in the capture file. These can optionally be restored during replay to their capture-time values with the <code>gfxrecon-replay-renamed.py</code> utility.</td>
</tr>
<tr class="odd">
<td>Log Level</td>
<td>GFXRECON_LOG_LEVEL</td>
<td>STRING</td>
<td>Specify the highest level message to log. Options are: <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, and <code>fatal</code>. The specified level and all levels listed after it will be enabled for logging. For example, choosing the <code>warning</code> level will also enable the <code>error</code> and <code>fatal</code> levels. Default is: <code>info</code></td>
</tr>
<tr class="even">
<td>Log Output to Console</td>
<td>GFXRECON_LOG_OUTPUT_TO_CONSOLE</td>
<td>BOOL</td>
<td>Log messages will be written to stdout. Default is: <code>true</code></td>
</tr>
<tr class="odd">
<td>Log File</td>
<td>GFXRECON_LOG_FILE</td>
<td>STRING</td>
<td>When set, log messages will be written to a file at the specified path. Default is: Empty string (file logging disabled).</td>
</tr>
<tr class="even">
<td>Log Detailed</td>
<td>GFXRECON_LOG_DETAILED</td>
<td>BOOL</td>
<td>Include name and line number from the file responsible for the log message. Default is: <code>false</code></td>
</tr>
<tr class="odd">
<td>Log Allow Indents</td>
<td>GFXRECON_LOG_ALLOW_INDENTS</td>
<td>BOOL</td>
<td>Apply additional indentation formatting to log messages. Default is: <code>false</code></td>
</tr>
<tr class="even">
<td>Log Break on Error</td>
<td>GFXRECON_LOG_BREAK_ON_ERROR</td>
<td>BOOL</td>
<td>Trigger a debug break when logging an error. Default is: <code>false</code></td>
</tr>
<tr class="odd">
<td>Log File Create New</td>
<td>GFXRECON_LOG_FILE_CREATE_NEW</td>
<td>BOOL</td>
<td>Specifies that log file initialization should overwrite an existing file when true, or append to an existing file when false. Default is: <code>true</code></td>
</tr>
<tr class="even">
<td>Log File Flush After Write</td>
<td>GFXRECON_LOG_FILE_FLUSH_AFTER_WRITE</td>
<td>BOOL</td>
<td>Flush the log file to disk after each write when true. Default is: <code>false</code></td>
</tr>
<tr class="odd">
<td>Log File Keep Open</td>
<td>GFXRECON_LOG_FILE_KEEP_OPEN</td>
<td>BOOL</td>
<td>Keep the log file open between log messages when true, or close and reopen the log file for each message when false. Default is: <code>true</code></td>
</tr>
<tr class="even">
<td>Log Output to Debug Console</td>
<td>GFXRECON_LOG_OUTPUT_TO_OS_DEBUG_STRING</td>
<td>BOOL</td>
<td>Windows only option. Log messages will be written to the Debug Console with <code>OutputDebugStringA</code>. Default is: <code>false</code></td>
</tr>
<tr class="odd">
<td>Memory Tracking Mode</td>
<td>GFXRECON_MEMORY_TRACKING_MODE</td>
<td>STRING</td>
<td>Specifies the memory tracking mode to use for detecting modifications to mapped Vulkan memory objects. Available options are: <code>page_guard</code>, <code>userfaultfd</code>, <code>assisted</code>, and <code>unassisted</code>. See <a href="#understanding-gfxreconstruct-layer-memory-capture">Understanding GFXReconstruct Layer Memory Capture</a> for more details. Default is <code>page_guard</code>.</td>
</tr>
<tr class="even">
<td>Page Guard Copy on Map</td>
<td>GFXRECON_PAGE_GUARD_COPY_ON_MAP</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, copies the content of the mapped memory to the shadow memory immediately after the memory is mapped. Default is: <code>true</code></td>
</tr>
<tr class="odd">
<td>Page Guard Separate Read Tracking</td>
<td>GFXRECON_PAGE_GUARD_SEPARATE_READ</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, copies the content of pages accessed for read from mapped memory to shadow memory on each read. Can overwrite unprocessed shadow memory content when an application is reading from and writing to the same page. Default is: <code>true</code></td>
</tr>
<tr class="even">
<td>Page Guard External Memory</td>
<td>GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, use the VK_EXT_external_memory_host extension to eliminate the need for shadow memory allocations. For each memory allocation from a host visible memory type, the capture layer will create an allocation from system memory, which it can monitor for write access, and provide that allocation to vkAllocateMemory as external memory. Only available on Windows. Default is <code>false</code></td>
</tr>
<tr class="odd">
<td>Page Guard Persistent Memory</td>
<td>GFXRECON_PAGE_GUARD_PERSISTENT_MEMORY</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, this option changes the way that the shadow memory used to detect modifications to mapped memory is allocated. The default behavior is to allocate and copy the mapped memory range on map and free the allocation on unmap. When this option is enabled, an allocation with a size equal to that of the object being mapped is made once on the first map and is not freed until the object is destroyed. This option is intended to be used with applications that frequently map and unmap large memory ranges, to avoid frequent allocation and copy operations that can have a negative impact on performance. This option is ignored when GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY is enabled. Default is <code>false</code></td>
</tr>
<tr class="even">
<td>Page Guard Align Buffer Sizes</td>
<td>GFXRECON_PAGE_GUARD_ALIGN_BUFFER_SIZES</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, this option overrides the Vulkan API calls that report buffer memory properties to report that buffer sizes and alignments must be a multiple of the system page size. This option is intended to be used with applications that perform CPU writes and GPU writes/copies to different buffers that are bound to the same page of mapped memory, which may result in data being lost when copying pages from the <code>page_guard</code> shadow allocation to the real allocation. This data loss can result in visible corruption during capture. Forcing buffer sizes and alignments to a multiple of the system page size prevents multiple buffers from being bound to the same page, avoiding data loss from simultaneous CPU writes to the shadow allocation and GPU writes to the real allocation for different buffers bound to the same page. This option is only available for the Vulkan API. Default is <code>true</code></td>
</tr>
<tr class="odd">
<td>Page Guard Unblock SIGSEGV</td>
<td>GFXRECON_PAGE_GUARD_UNBLOCK_SIGSEGV</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled and in the case that SIGSEGV has been marked as blocked in thread's signal mask, setting this enviroment variable to <code>true</code> will forcibly re-enable the signal in the thread's signal mask. Default is <code>false</code></td>
</tr>
<tr class="even">
<td>Page Guard Signal Handler Watcher</td>
<td>GFXRECON_PAGE_GUARD_SIGNAL_HANDLER_WATCHER</td>
<td>BOOL</td>
<td>When the <code>page_guard</code> memory tracking mode is enabled, setting this enviroment variable to <code>true</code> will spawn a thread which will will periodically reinstall the <code>SIGSEGV</code> handler if it has been replaced by the application being traced. Default is <code>false</code></td>
</tr>
<tr class="odd">
<td>Page Guard Signal Handler Watcher Max Restores</td>
<td>GFXRECON_PAGE_GUARD_SIGNAL_HANDLER_WATCHER_MAX_RESTORES</td>
<td>INTEGER</td>
<td>Sets the number of times the watcher will attempt to restore the signal handler. Setting it to a negative will make the watcher thread run indefinitely. Default is <code>1</code></td>
</tr>
<tr class="even">
<td>Force Command Serialization</td>
<td>GFXRECON_FORCE_COMMAND_SERIALIZATION</td>
<td>BOOL</td>
<td>Sets exclusive locks(unique_lock) for every ApiCall. It can avoid external multi-thread to cause captured issue.</td>
</tr>
<tr class="odd">
<td>Queue Zero Only</td>
<td>GFXRECON_QUEUE_ZERO_ONLY</td>
<td>BOOL</td>
<td>Forces to using only QueueFamilyIndex: 0 and queueCount: 1 on capturing to avoid replay error for unavailble VkQueue.</td>
</tr>
<tr class="even">
<td>Allow Pipeline Compile Required</td>
<td>GFXRECON_ALLOW_PIPELINE_COMPILE_REQUIRED</td>
<td>BOOL</td>
<td>The default behaviour forces VK_PIPELINE_COMPILE_REQUIRED to be returned from Create*Pipelines calls which have VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT set, and skips dispatching and recording the calls. This forces applications to fallback to recompiling pipelines without caching, the Vulkan calls for which will be captured. Enabling this option causes capture to record the application's calls and implementation's return values unmodified, but the resulting captures are fragile to changes in Vulkan implementations if they use pipeline caching.</td>
</tr>
<tr class="odd">
<td>Stop Recording Calls in Threads With Invalid Data</td>
<td>GFXRECON_SKIP_THREADS_WITH_INVALID_DATA</td>
<td>BOOL</td>
<td>When a thread is encountered which contains data that is unexpected, skip the data and mark the thread as skippable. This is important especially in OpenXR where other API commands (such as Vulkan) may be generated inside of the OpenXR commands, but may still be referenced in some fashion outside of the OpenXR commands. This results in issues during replay. So, this option prevents those commands, and the threads containing those commands from being recorded to the capture file. Default is <code>false</code> and it is only valid when OpenXR capture is enabled.</td>
</tr>
</tbody>
</table>
<h4 id="memory-tracking-known-issues">Memory Tracking Known Issues</h4>
<h3 id="capture-limitations">Capture Limitations</h3>
<h4 id="conflicts-with-crash-detection-libraries">Conflicts With Crash Detection Libraries</h4>
<p>As described in <a href="#understanding-gfxreconstruct-layer-memory-capture">Understanding GFXReconstruct Layer Memory Capture</a>, the capture layer, when it utilizing the <code>page_guard</code> mechanism, it uses a signal handler to detect modifications to mapped memory. Only one signal handler for that signal can be registered at a time, which can lead to a potential conflict with crash detection libraries that will also register a signal handler.</p>
<p>Conflict between the <code>page_guard</code> mechanism and crash detection libraries depends on the order with which each component registers its signal handler. The capture layer will not register its signal handler until the first call to <code>vkMapMemory</code>. As long as the application initializes the crash detection library before calling <code>vkMapMemory</code>, there should be no conflict.</p>
<p>The conflict occurs when the application initializes its Vulkan component and its crash detection library concurrently. Applications have been observed to initialize Vulkan and begin uploading resources with one or more threads, while at the same time initializing a crash detection library from another thread. For this scenario, the crash detection library sets its signal handler after the first call to <code>vkMapMemory</code>, while a resource upload thread is actively writing to the mapped memory. After the crash detection library sets its signal handler, it immediately receives a SIGSEGV event generated by the concurrent write to mapped memory, which it detects as a crash and terminates the application.</p>
<p><code>userfaultfd</code> mechanism was introduced in order to work around such conflicts.</p>
<h4 id="memory-tracking-limitations">Memory Tracking Limitations</h4>
<p>There is a limitation with the <code>page_guard</code> memory tracking method used by the GFXReconstruct capture layer. The logic behind that method is to apply a memory protection to the guarded/shadowed regions so that accesses made by the user to trigger a segmentation fault which is handled by GFXReconstruct. If the access is made by a system call (like <code>fread()</code>) then there won't be a segmentation fault generated and the function will fail. As a result the mapped region will not be updated.</p>
<h4 id="settings-file">Settings File</h4>
<p>Capture options may also be specified through a layer settings file. The layer settings file will be loaded before the environment variables are processed, allowing environment variables to override individual settings file entries.</p>
<p>The <code>VK_LAYER_SETTINGS_PATH</code> environment variable is used to enable a settings file. The environment variable may be set as either the path to the folder containing a file named <code>vk_layer_settings.txt</code> or the full path to a file with a custom name. When set to a folder, the capture layer will try to open a file in that folder named <code>vk_layer_settings.txt</code>. When set to a file, the capture layer will try to open a file with the specified name.</p>
<p>The settings file may be combined with settings files for other layers. The capture layer will ignore entries that do not start with the 'lunarg_gfxreconstruct.' prefix.</p>
<p>A sample layer settings file, documenting each available setting, can be found in the GFXReconstruct GitHub repository at <code>layer/vk_layer_settings.txt</code>. Most binary distributions of the GFXReconstruct software will also include a sample settings file.</p>
<h4 id="layer-settings-via-vk_ext_layer_settings">Layer Settings via VK_EXT_layer_settings</h4>
<p>An alternative way to configure the GFXReconstruct Vulkan capture layer is via the Vulkan <code>VK_EXT_layer_settings</code> extension, which allows settings to be passed directly through the Vulkan API at instance creation time. This is especially useful in environments where environment variables and settings files are not available or convenient (such as some launchers or embedded systems).</p>
<p>GFXReconstruct supports reading capture options from <code>VkLayerSettingEXT</code> structures provided in the <code>pNext</code> chain of <code>VkInstanceCreateInfo</code> when creating a Vulkan instance. This allows you to specify settings programmatically, without relying on environment variables or external files.</p>
<p>To use this feature, add a <code>VkLayerSettingsCreateInfoEXT</code> structure to the <code>pNext</code> chain of your <code>VkInstanceCreateInfo</code>, and include settings for the <code>VK_LAYER_LUNARG_gfxreconstruct</code> layer. For example, to set the capture file name:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">const</span> <span class="dt">char</span>* capture_file_value[] = { <span class="st">&quot;my_capture.gfxr&quot;</span> };</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3">VkLayerSettingEXT capture_file_setting = {</a>
<a class="sourceLine" id="cb9-4" title="4">    .pLayerName = <span class="st">&quot;VK_LAYER_LUNARG_gfxreconstruct&quot;</span>,</a>
<a class="sourceLine" id="cb9-5" title="5">    .pSettingName = <span class="st">&quot;capture_file&quot;</span>,</a>
<a class="sourceLine" id="cb9-6" title="6">    .type = VK_LAYER_SETTING_TYPE_STRING_EXT,</a>
<a class="sourceLine" id="cb9-7" title="7">    .valueCount = <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb9-8" title="8">    .pValues = capture_file_value,</a>
<a class="sourceLine" id="cb9-9" title="9">};</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11">VkLayerSettingsCreateInfoEXT layer_settings_info = {</a>
<a class="sourceLine" id="cb9-12" title="12">    .sType = VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,</a>
<a class="sourceLine" id="cb9-13" title="13">    .pNext = NULL,</a>
<a class="sourceLine" id="cb9-14" title="14">    .settingCount = <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb9-15" title="15">    .pSettings = &amp;capture_file_setting</a>
<a class="sourceLine" id="cb9-16" title="16">};</a>
<a class="sourceLine" id="cb9-17" title="17"></a>
<a class="sourceLine" id="cb9-18" title="18">VkInstanceCreateInfo instance_info = {</a>
<a class="sourceLine" id="cb9-19" title="19">    .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,</a>
<a class="sourceLine" id="cb9-20" title="20">    .pNext = &amp;layer_settings_info,</a>
<a class="sourceLine" id="cb9-21" title="21">    <span class="co">// ... other fields ...</span></a>
<a class="sourceLine" id="cb9-22" title="22">};</a></code></pre></div>
<p>Supported settings include:</p>
<ul>
<li><code>capture_file</code> (string): Path to use when creating the capture file (same as <code>GFXRECON_CAPTURE_FILE</code>).</li>
</ul>
<h4 id="selecting-settings-for-the-page_guard-memory-tracking-mode">Selecting Settings for the page_guard Memory Tracking Mode</h4>
<p>The default settings selected for the <code>page_guard</code> memory tracking mode are the settings that are most likely to work on a given platform, but may not provide the best performance for all cases.</p>
<p>For Windows, setting <code>GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY</code> to <code>true</code> is recommended. If capture does not work with this setting, or a different operating system is being used, try the default settings.</p>
<p>If capture performs poorly with the the default settings, try setting <code>GFXRECON_PAGE_GUARD_PERSISTENT_MEMORY</code> to <code>true</code>.</p>
<p>If corruption is observed during capture, try setting <code>GFXRECON_PAGE_GUARD_ALIGN_BUFFER_SIZES</code> to <code>true</code>. If this does not help, try setting <code>GFXRECON_PAGE_GUARD_SEPARATE_READ</code> to <code>false</code>.</p>
<h3 id="capture-files">Capture Files</h3>
<p>Capture files are created on the first call to <code>vkCreateInstance</code>, when the Vulkan loader loads the capture layer, and are closed on <code>vkDestroyInstance</code>, when the last active instance is destroyed and the layer is unloaded.</p>
<p>If multiple instances are active concurrently, only one capture file will be created. If multiple instances are active consecutively (i.e. an instance is created and destroyed before the next instance is created), the creation of each instance will generate a new file. For applications that create multiple instances consecutively, it will be necessary to enable capture file timestamps to prevent each new instance from overwriting the file created by the previous instance.</p>
<p>If the layer fails to open the capture file, it will make the call to <code>vkCreateInstance</code> fail, returning <code>VK_ERROR_INITIALIZATION_FAILED</code>.</p>
<h4 id="specifying-capture-file-location">Specifying Capture File Location</h4>
<p>The capture file's save location can be specified by setting the <code>GFXRECON_CAPTURE_FILE</code> environment variable, described above in the <a href="#layer-options">Layer Options</a> section.</p>
<h4 id="timestamps">Timestamps</h4>
<p>When capture file timestamps are enabled, a timestamp with an ISO 8601-based format will be added to the name of every file created by the layer. The timestamp is generated when the capture file is created by the layer's <code>vkCreateInstance</code> function and is added to the base filename specified through the <code>GFXRECON_CAPTURE_FILE</code> environment variable. Timestamps have the form:</p>
<pre class="text"><code>_yyyymmddThhmmss
</code></pre>
<p>where the lower-case letters stand for: Year, Month, Day, Hours, Minutes, Seconds. The <code>T</code> is a designator that separates the date and time components. Time is reported for the local timezone and is specified with the 24-hour format.</p>
<p>The following example shows a timestamp that was added to a file that was originally named <code>gfxrecon_capture.gfxr</code> and was created at 2:35 PM on November 25, 2018: <code>gfxrecon_capture_20181125T143527.gfxr</code></p>
<h3 id="trimmed-captures">Trimmed Captures</h3>
<p>Trimmed captures are created when GFXR is configured to start capturing at some later time in execution.</p>
<p>To create a trimmed capture one of the trimming options can be used. For example on desktop there is the <code>GFXRECON_CAPTURE_FRAMES</code> environment variable, which specifies the frame ranges to capture, each range generating a separate trimmed capture file. There's also the <code>GFXRECON_CAPTURE_TRIGGER</code> environment variable. Each time the hot key is pressed a new trimmed capture is started/stopped.</p>
<p>An existing capture file can be trimmed by replaying the capture with the capture layer enabled and a trimming frame range or trimming hot key enabled. (However, replay for some content may be fast enough using the hot key may be difficult.) Here's an example command-line that replays an existing capture with the capture layer enabled and configured to capture only from frame 100 through frame 200 into a new capture file:</p>
<p>`gfxrecon-capture.py -f 100-200 gfxrecon-replay gfxrecon-example-capture.gfxr``</p>
<h3 id="asset-files">Asset files</h3>
<p>When doing a trimmed capture, <code>GFXRECON_CAPTURE_USE_ASSET_FILE</code> gives the option to dump all assets (images, buffers and descriptors) separetly in a different capture file called the asset file. When this option is enabled assets are tracked and only those that are changed during a tracking period (outside of a trim range) are dumped into the asset file. This first time a trim range is encountered (or the hotkey is pressed) all assets will be dumped, but the next time this happens only the assets that have been changed will be dumped. This should speed up the dumping process.</p>
<h3 id="capture-script">Capture Script</h3>
<p>The <code>gfxrecon-capture-vulkan.py</code> tool is a convenience script that can be used to start a capture and specify the capture options using a single command.</p>
<pre class="text"><code>usage: gfxrecon-capture-vulkan.py [-h]
                                  [-w dir]
                                  [-o captureFile]
                                  [-f captureFrames]
                                  [--no-file-timestamp]
                                  [--trigger {F1-F12,TAB,CTRL}]
                                  [--compression-type {LZ4,ZLIB,ZSTD,NONE}]
                                  [--file-flush]
                                  [--log-level {debug,info,warn,error,fatal}]
                                  [--log-timestamps]
                                  [--log-file &lt;file&gt;]
                                  [--memory-tracking-mode {page_guard,assisted,unassisted}]
                                  &lt;program&gt; [&lt;programArgs&gt;]

Create a capture of a Vulkan program.

positional arguments:
  &lt;program&gt; [&lt;program args&gt;]
                        Program to capture, optionally followed by program
                        arguments

optional arguments:
  -h, --help            show this help message and exit
  -w &lt;dir&gt;, --working-dir &lt;dir&gt;
                        Set CWD to this directory before running the program
  -o &lt;captureFile&gt;, --capture-file &lt;captureFile&gt;
                        Name of the capture file, default is
                        gfxrecon_capture.gfxr
  -f &lt;captureFrames&gt;, --capture-frames &lt;captureFrames&gt;
                        List of frames to capture, default is all frames
  --no-file-timestamp   Do not add a timestamp to the capture file name
  --trigger {F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,TAB,CTRL}
                        Specify a hotkey to start/stop capture
  --compression-type {LZ4,ZLIB,ZSTD,NONE}
                        Specify the type of compression to use in the capture
                        file, default is LZ4
  --file-flush          Flush output stream after each packet is written to
                        capture file
  --log-level {debug,info,warn,error,fatal}
                        Specify highest level message to log, default is info
  --log-timestamps      Output a timestamp in front of each log message.
  --log-file &lt;logFile&gt;  Write log messages to a file at the specified path.
                        Default is: Empty string (file logging disabled)
  --memory-tracking-mode {page_guard,assisted,unassisted}
                        Method to use to track changes to memory mapped objects:
                           page_guard: use guard pages to track changes (default)
                           assisted:   application will call vkFlushMappedMemoryRanges
                                       for memory to be written to the capture file
                           unassisted: all mapped memory will be written to the
                                       capture file during VkQueueSubmit and VkUnmapMemory
</code></pre>
<p>Most of the options for <code>gfxrecon-capture-vulkan.py</code> result in the script setting the appropriate capture layer environment variable, then invoking the program to be captured. Environment variables not set by <code>gfxrecon-capture-vulkan.py</code> can be set manually before running <code>gfxrecon-capture-vulkan.py</code> and they will be detected by the capture layer.</p>
<p>The <code>gfxrecon-capture-vulkan.py</code> tool is a Python3 script. In order to use it, a Python3 interpreter must first be installed. Once Python3 is installed, you should be able to invoke <code>gfxrecon-capture-vulkan.py</code> by simply typing:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">gfxrecon-capture-vulkan.py</span> -o vkcube.gfxr vkcube</a></code></pre></div>
<p>On Windows, after installing Python3, be sure to associate the <code>.py</code> file extension with the Python3 interpreter before you run the script.</p>
<h2 id="replaying-api-calls">Replaying API Calls</h2>
<p>The GFXReconstruct Replay tool, <code>gfxrecon-replay</code>, can be used to replay files captured with or generated by other GFXReconstruct components.</p>
<h3 id="command-line-arguments">Command Line Arguments</h3>
<p>The <code>gfxrecon-replay</code> tool for desktop accepts the following command line arguments:</p>
<pre class="text"><code>gfxrecon-replay         [-h | --help] [--version] [--cpu-mask &lt;binary-mask&gt;] [--gpu &lt;index&gt;]
                        [--pause-frame &lt;N&gt;] [--paused] [--sync] [--screenshot-all]
                        [--screenshots &lt;N1(-N2),...&gt;] [--screenshot-format &lt;format&gt;]
                        [--screenshot-dir &lt;dir&gt;] [--screenshot-prefix &lt;file-prefix&gt;]
                        [--screenshot-scale SCALE] [--screenshot-size WIDTHxHEIGHT]
                        [--screenshot-interval &lt;N&gt;]
                        [--capture]
                        [--sfa | --skip-failed-allocations] [--replace-shaders &lt;dir&gt;]
                        [--opcd | --omit-pipeline-cache-data] [--wsi &lt;platform&gt;]
                        [--surface-index &lt;N&gt;] [--remove-unsupported] [--validate]
                        [-m &lt;mode&gt; | --memory-translation &lt;mode&gt;]
                        [--fwo &lt;x,y&gt; | --force-windowed-origin &lt;x,y&gt;]
                        [--swapchain MODE] [--use-captured-swapchain-indices]
                        [--present-mode &lt;mode&gt;]
                        [--mfr|--measurement-frame-range &lt;start-frame&gt;-&lt;end-frame&gt;]
                        [--measurement-file &lt;file&gt;] [--quit-after-measurement-range]
                        [--flush-measurement-range]
                        [--log-level &lt;level&gt;] [--log-file &lt;file&gt;] [--log-debugview]
                        [--debug-messenger-level &lt;level&gt;]
                        [--no-debug-popup] [--use-colorspace-fallback]
                        [--wait-before-present]
                        [--dump-resources &lt;submit-index,command-index,draw-call-index&gt;]
                        [--dump-resources &lt;arg&gt;]
                        [--dump-resources &lt;filename&gt;]
                        [--dump-resources &lt;filename&gt;.json]
                        [--dump-resources-before-draw] [--dump-resources-scale &lt;scale&gt;]
                        [--dump-resources-dir &lt;dir&gt;]
                        [--dump-resources-image-format &lt;format&gt;]
                        [--dump-resources-dump-depth-attachment]
                        [--dump-resources-dump-color-attachment-index &lt;index&gt;]
                        [--dump-resources-dump-vertex-index-buffers]
                        [--dump-resources-json-output-per-command]
                        [--dump-resources-dump-immutable-resources]
                        [--dump-resources-dump-all-image-subresources] &lt;file&gt;
                        [--pbi-all] [--pbis &lt;index1,index2&gt;]
                        [--pipeline-creation-jobs | --pcj &lt;num_jobs&gt;]
                        [--deduplicate-device]


Required arguments:
  &lt;file&gt;                Path to the capture file to replay.

Optional arguments:
  -h                    Print usage information and exit (same as --help).
  --version             Print version information and exit.
  --log-level &lt;level&gt;   Specify highest level message to log. Options are:
                        debug, info, warning, error, and fatal. Default is info.
  --log-timestamps      Output a timestamp in front of each log message.
  --log-file &lt;file&gt;     Write log messages to a file at the specified path.
                        Default is: Empty string (file logging disabled).
  --log-debugview       Log messages with OutputDebugStringA. Windows only.
  --debug-messenger-level &lt;level&gt;
                        Specify highest debug messenger severity level. Options
                        are: debug, info, warning, and error. Default is
                        warning.
  --cpu-mask &lt;binary-mask&gt;
                        Set of CPU cores used by the replayer.
                        `binary-mask` is a succession of &#39;0&#39; and &#39;1&#39; read from left
                        to right that specifies used/unused cores.
                        For example &#39;10010&#39; activates the first and
                        fourth cores and deactivate all other cores.
                        If the option is not set, all cores can be used. If the option
                        is set only for some cores, the other cores are not used.
  --gpu &lt;index&gt;         Use the specified device for replay, where index
                        is the zero-based index to the array of physical devices
                        returned by vkEnumeratePhysicalDevices.  Replay may fail
                        if the specified device is not compatible with the
                        original capture devices.
  --gpu-group &lt;index&gt;   Use the specified device group for replay, where index
                        is the zero-based index to the array of physical device group
                        returned by vkEnumeratePhysicalDeviceGroups.  Replay may fail
                        if the specified device group is not compatible with the
                        original capture device group.
  --pause-frame &lt;N&gt;     Pause after replaying frame number N.
  --paused              Pause after replaying the first frame (same
                        as --pause-frame 1).
  --screenshot-all
                        Generate screenshots for all frames.  When this
                        option is specified, --screenshots is ignored.
  --screenshots &lt;N1[-N2][,...]&gt;
                        Generate screenshots for the specified frames.
                        Target frames are specified as a comma separated
                        list of frame ranges.  A frame range can be specified
                        as a single value, to specify a single frame, or as
                        two hyphenated values, to specify the first and last
                        frames to process.  Frame ranges should be specified in
                        ascending order and cannot overlap.  Note that frame
                        numbering is 1-based (i.e. the first frame is frame 1).
                        Example: 200,301-305 will generate six screenshots.
  --screenshot-interval &lt;N&gt;
                        Specifies the number of frames between two screenshots
                        within a screenshot range.
                        Example: If screenshot range is 10-15 and interval is 2,
                        screenshot will be generated for frames 10, 12 and 14.
                        Default is 1.
  --screenshot-format &lt;format&gt;
                        Image file format to use for screenshot generation.
                        Available formats are:
                            bmp         Bitmap file format.  This is the default format.
                            png         Portable Network Graphics file format.
  --screenshot-dir &lt;dir&gt;
                        Directory to write screenshots.  Default is the current
                        working directory.
  --screenshot-prefix &lt;file-prefix&gt;
                        Prefix to apply to the screenshot file name.  Default is
                        &quot;screenshot&quot;, producing file names similar to
                        &quot;screenshot_frame8049.bmp&quot;.
  --screenshot-scale SCALE
                        Specify a decimal factor which will determine screenshot
                        sizes. The factor will be multiplied with the swapchain
                        images dimension to determine the screenshot dimensions.
                        Default is 1.0.
  --screenshot-size WIDTHxHEIGHT
                        Specify desired screenshot dimensions. Leaving this
                        unspecified screenshots will use the swapchain images
                        dimensions. If --screenshot-scale is also specified then
                        this option is ignored.
  --capture             Capture the replaying GFXR file. Capture uses the same log
                        options as replay. All other capture option behavior and
                        usage is the same as when capturing with the GFXR layer. The
                        capture functionality is included in the `gfxrecon-replay`
                        executable--no GFXR capture layer is added to the Vulkan layer
                        chain.
  --sfa                 Skip vkAllocateMemory, vkAllocateCommandBuffers, and
                        vkAllocateDescriptorSets calls that failed during
                        capture (same as --skip-failed-allocations).
  --replace-shaders &lt;dir&gt; Replace the shader code in each CreateShaderModule
                        with the contents of the file &lt;dir&gt;/sh&lt;handle_id&gt; if found, where
                        &lt;handle_id&gt; is the handle id of the CreateShaderModule call.
                        See gfxrecon-extract.
  --opcd                Omit pipeline cache data from calls to
                        vkCreatePipelineCache and skip calls to
                        vkGetPipelineCacheData (same as
                        --omit-pipeline-cache-data).
  --wsi &lt;platform&gt;      Force replay to use the specified wsi platform.
                        Available platforms are:
                        auto,display,headless,metal,wayland,win32,xcb,xlib
  --surface-index &lt;N&gt;   Restrict rendering to the Nth surface object created.
                        Used with captures that include multiple surfaces.  Default
                        is -1 (render to all surfaces).
  --sync                Synchronize after each queue submission with vkQueueWaitIdle.
  --remove-unsupported  Remove unsupported extensions and features from instance
                        and device creation parameters.
  --validate            Enables the Khronos Vulkan validation layer when replaying a
                        Vulkan capture or the Direct3D debug layer when replaying a
                        Direct3D 12 capture.
  -m &lt;mode&gt;             Enable memory translation for replay on GPUs with memory
                        types that are not compatible with the capture GPU&#39;s
                        memory types.  Available modes are:
                            none        No memory translation is performed.  This
                                        is the default behavior.
                            remap       Attempt to map capture memory types to
                                        compatible replay memory types, without
                                        altering memory allocation behavior.
                            realign     Adjust memory allocation sizes and
                                        resource binding offsets based on
                                        replay memory properties.
                            rebind      Change memory allocation behavior based
                                        on resource usage and replay memory
                                        properties.  Resources may be bound
                                        to different allocations with different
                                        offsets.  Uses VMA to manage allocations
                                        and suballocations.
  --fwo &lt;x,y&gt;           Force windowed mode if not already, and allow setting of a custom window location.
                        (Same as --force-windowed-origin)
  --no-debug-popup      Disable the &#39;Abort, Retry, Ignore&#39; message box
                        displayed when abort() is called (Windows debug only).
  --swapchain MODE      Choose a swapchain mode to replay. Available modes are:
                            virtual     Virtual Swapchain of images which match
                                        the swapchain in effect at capture time and
                                        which are copied to the underlying swapchain of the
                                        implementation being replayed on. This is default.
                            captured    Use the swapchain indices stored in the
                                        capture directly on the swapchain setup for replay.
                            offscreen   Disable creating swapchains, surfaces
                                        and windows. To see rendering, add the --screenshots option.
  --present-mode &lt;mode&gt; Set swapchain&#39;s VkPresentModeKHR.
                        Available modes are:
                            capture: Present mode used at capture time.
                            immediate: VK_PRESENT_MODE_IMMEDIATE_KHR
                            mailbox: VK_PRESENT_MODE_MAILBOX_KHR
                            fifo: VK_PRESENT_MODE_FIFO_KHR
                            fifo_relaxed: VK_PRESENT_MODE_FIFO_RELAXED_KHR
  --vssb
                        Skip blit to real swapchain to gain performance during replay.
  --use-captured-swapchain-indices
                        Same as &quot;--swapchain captured&quot;. Ignored if the &quot;--swapchain&quot; option is used.
  --measurement-frame-range &lt;start_frame&gt;-&lt;end_frame&gt;
              Custom framerange to measure FPS for.
              This range will include the start frame but not the end frame.
              The measurement frame range defaults to all frames except the loading
              frame but can be configured for any range. If the end frame is past the
              last frame in the trace it will be clamped to the frame after the last
              (so in that case the results would include the last frame).
  --measurement-file &lt;file&gt;
              Write measurements to a file at the specified path.
              Default is: &#39;/sdcard/gfxrecon-measurements.json&#39; on android and
              &#39;./gfxrecon-measurements.json&#39; on desktop.
  --quit-after-measurement-range
              If this is specified the replayer will abort
              when it reaches the &lt;end_frame&gt; specified in
              the --measurement-frame-range argument.
  --flush-measurement-range
              If this is specified the replayer will flush
              and wait for all current GPU work to finish at the
              start and end of the measurement range.
  --flush-inside-measurement-range
              If this is specified the replayer will flush and wait
              for all current GPU work to finish at the end of each
              frame inside the measurement range.
  --use-colorspace-fallback
              Swap the swapchain color space if unsupported by replay device.
              Check if color space is not supported by replay device and
              fallback to VK_COLOR_SPACE_SRGB_NONLINEAR_KHR.
  --offscreen-swapchain-frame-boundary
              Should only be used with offscreen swapchain.
              Activates the extension VK_EXT_frame_boundary (always supported if
              trimming, checks for driver support otherwise) and inserts command
              buffer submission with VkFrameBoundaryEXT where vkQueuePresentKHR
              was called in the original capture.
              This allows preserving frames when capturing a replay that uses.
              offscreen swapchain.
  --sgfs &lt;status&gt;
              Specify behaviour to skip calls to vkWaitForFences and vkGetFenceStatus:
                status=0 : Don&#39;t skip
                status=1 : Skip unsuccessful calls
                status=2 : Allways skip
              If no skip frame range is specified (--sgfr), the status applies to all
              frames.
  --sgfr &lt;frame-ranges&gt;
              Frame ranges where --sgfs applies. The format is:
                &lt;frame-start-1&gt;-&lt;frame-end-1&gt;[,&lt;frame-start-1&gt;-&lt;frame-end-1&gt;]*
  --wait-before-present
              Force wait on completion of queue operations for all queues
              before calling Present. This is needed for accurate acquisition
              of instrumentation data on some platforms.
  --dump-resources &lt;submit-index,command-index,draw-call-index&gt;
              The capture file will be examined, and &lt;submit-index,command-index,draw-call-index&gt;
              will be converted to &lt;arg&gt; as used in --dump-resources &lt;arg&gt; below.
              The converted args will be used as the args for dump resources.
  --dump-resources &lt;arg&gt;
              &lt;arg&gt; is BeginCommandBuffer=&lt;n&gt;,Draw=&lt;o&gt;,BeginRenderPass=&lt;p&gt;,
              NextSubpass=&lt;q&gt;,EndRenderPass=&lt;r&gt;,Dispatch=&lt;s&gt;,TraceRays=&lt;t&gt;,
              QueueSubmit=&lt;u&gt;
              Dump gpu resources after the given vmCmdDraw*, vkCmdDispatch, or vkCmdTraceRaysKHR
              is replayed. The parameter for each is a block index from the capture file. The
              additional parameters are used to identify during which occurence of the
              vkCmdDraw/vkCmdDispatch/vkCmdTraceRaysKHR resources will be dumped.  NextSubPass can
              be repeated 0 or more times to indicate subpasses within a render pass.  Note that
              the minimal set of parameters must be one of:
                  BeginCmdBuffer, Draw, BeginRenderPass, EndRenderPass, and QueueSubmit
                  BeginCmdBuffer, Dispatch and QueueSubmit
                  BeginCmdBuffer, TraceRays and QueueSubmit
  --dump-resources &lt;filename&gt;
              Extract --dump-resources block indices args from the specified file, with each line in
              the file containing a comma or space separated list of the parameters to
              --dump-resources &lt;arg&gt;. The file can contain multiple lines specifying multiple dumps.
  --dump-resources &lt;filename&gt;.json
              Extract --dump-resources block indices args from the specified json file. The format for the
              json file is documented in detail in the gfxreconstruct documentation.
  --dump-resources-image-format &lt;format&gt;
              Image file format to use for image resource dumping.
              Available formats are:
                  bmp         Bitmap file format.  This is the default format.
                  png         Png file format.
  --dump-resources-before-draw
              In addition to dumping gpu resources after the CmdDraw, CmdDispatch and CmdTraceRays calls
              specified by the --dump-resources &lt;arg&gt;, also dump resources before those
              calls.
  --dump-resources-scale &lt;scale&gt;
              Scale images generated by dump resources by the given scale factor. The scale factor must
              be a floating point number greater than 0. Values greater than 10 are capped at 10. Default
              value is 1.0.
  --dump-resources-dir &lt;dir&gt;
              Directory to write dump resources output files. Default is the current working directory.
  --dump-resources-image-format &lt;format&gt;
              Image file format to use when dumping image resources. Available formats are: bmp, png
  --dump-resources-dump-depth-attachment
              Configures whether to dump the depth attachment when dumping draw calls. Default is disabled.
  --dump-resources-dump-color-attachment-index &lt;index&gt;
              Specify which color attachment to dump when dumping draw calls. It should be an unsigned zero
              based integer. Default is to dump all color attachments.
  --dump-resources-dump-vertex-index-buffers
              Enables dumping of vertex and index buffers while dumping draw call resources.
  --dump-resources-json-output-per-command
              Enables storing a json output file for each dumped command. Overrides default behavior which
              is generating one output json file that contains the information for all dumped commands.
  --dump-resources-dump-immutable-resources
              Enables dumping of resources that are used as inputs in the commands requested for dumping.
  --dump-resources-dump-all-image-subresources
              Enables dumping of all image sub resources (mip map levels and array layers).
  --dump-resources-dump-raw-images
              When enabled all image resources will be dumped verbatim as raw bin files.
  --dump-resources-dump-separate-alpha
              When enabled alpha channel of dumped images will be dumped in a separate file.
  --pbi-all
              Print all block information.
  --pbis &lt;index1,index2&gt;
              Print block information between block index1 and block index2.
  --pipeline-creation-jobs | --pcj &lt;num_jobs&gt;
              Specify the number of asynchronous pipeline-creation jobs as integer.
              If &lt;num_jobs&gt; is negative it will be added to the number of cpu-cores, e.g. -1 -&gt; num_cores - 1.
              Default: 0 (do not use asynchronous operations)
  --save-pipeline-cache &lt;cache-file&gt;
                        If set, produces pipeline caches at replay time instead of using
                        the one saved at capture time and save those caches in &lt;cache-file&gt;.
  --load-pipeline-cache &lt;cache-file&gt;
                        If set, loads data created by the `--save-pipeline-cache`
                        option in &lt;cache-file&gt; and uses it to create the pipelines instead
                        of the pipeline caches saved at capture time.
  --add-new-pipeline-caches
                        If set, allows gfxreconstruct to create new vkPipelineCache objects
                        when it encounters a pipeline created without cache. This option can
                        be used in coordination with `--save-pipeline-cache` and
                        `--load-pipeline-cache`.
  --quit-after-frame
              Specify a frame after which replay will terminate.

  --deduplicate-device
              If set, at most one VkDevice will be created for each VkPhysicalDevice for RenderDoc and DXVK case.
</code></pre>
<h3 id="key-controls">Key Controls</h3>
<p>The <code>gfxrecon-replay</code> tool for Desktop supports the following key controls:</p>
<table>
<thead>
<tr class="header">
<th>Key(s)</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Space, p</td>
<td>Toggle pause/play.</td>
</tr>
<tr class="even">
<td>Right arrow, n</td>
<td>Advance to the next frame when paused.</td>
</tr>
</tbody>
</table>
<h3 id="virtual-swapchain">Virtual Swapchain</h3>
<p>During replay, swapchain indices for present can be different from captured indices. Causes for this can include the swapchain image count differing between capture and replay, and <code>vkAcquireNextImageKHR</code> returning a different <code>pImageIndex</code> at replay to the one that was captured. These issues can cause unexpected rendering or even crashes.</p>
<p>Virtual Swapchain insulates higher layers in the Vulkan stack from these problems by creating a set of images, exactly matching the swapchain configuration at capture time, which it exposes for them to render into. Before a present, it copies the virtual image to a target swapchain image for display. Since this issue can happen in many situations, virtual swapchain is the default setup. If the user wants to bypass the feature and use the captured indices to present directly on the swapchain of the replay implementation, they should add the <code>--use-captured-swapchain-indices</code> option when invoking <code>gfxrecon-replay</code>.</p>
<h3 id="debug-mode-vma-errors">Debug mode VMA errors</h3>
<p>gfxrec-replay with the -m rebind option uses the Vulkan Memory Allocator library for memory allocations. If gfxrecon-replay is compiled debuggable, VMA_ASSERT errors in VMA can be trapped for debugging by setting GFXRECON_LOG_BREAK_ON_ERROR to true.</p>
<h3 id="fence-skipping">Fence skipping</h3>
<p>There can be situations where one wants to alter Vulkan fences behavior without being able to modifying the application. For example, for GPU performance measurements, we might want to "pack frames" when replaying by removing fences that we know unnecessary. For these situations, the options <code>--skip-get-fence-status</code>(<code>--sgfs</code>) and <code>--skip-get-fence-ranges</code>(<code>--sgfr</code>) have been created.</p>
<p>There are three possible status that can be set using <code>--sgfs</code>:</p>
<ul>
<li><code>0</code> - Don't skip: The default status, nothing particular happens.</li>
<li><code>1</code> - Skip unsuccessful: <code>vkWaitForFences</code>/<code>vkGetFenceStatus</code> is called only if the result at capture time was <code>VK_SUCCESS</code>. Else, the result obtained at capture time is directly returned.</li>
<li><code>2</code> - Skip all: <code>vkWaitForFences</code>/<code>vkGetFenceStatus</code> is never called and <code>VK_SUCCESS</code> is returned directly instead.</li>
</ul>
<p>The <code>--sgfr</code> option specify at which frames these conditions apply. If <code>--sgfr</code> is not specified, they apply to all frames.</p>
<h3 id="dumping-resources">Dumping resources</h3>
<p>GFXReconstruct offers the capability to dump resources when replaying a capture file. Detailed documentation of that feature can be found in <a href="./vulkan_dump_resources.html">vulkan_dump_resources.html</a></p>
<h2 id="other-capture-file-processing-tools">Other Capture File Processing Tools</h2>
<h3 id="capture-file-info">Capture File Info</h3>
<p>The <code>gfxrecon-info</code> tool prints statistics for a GFXReconstruct capture file, including information about the application, the physical device , device memory allocation, and device pipelines.</p>
<pre class="text"><code>gfxrecon-info - Print statistics for a GFXReconstruct capture file.

Usage:
  gfxrecon-info [-h | --help] [--version] &lt;file&gt;

Required arguments:
  &lt;file&gt;      The GFXReconstruct capture file to be processed.

Optional arguments:
  -h          Print usage information and exit (same as --help).
  --version   Print version information and exit.
</code></pre>
<h3 id="capture-file-compression">Capture File Compression</h3>
<p>The <code>gfxrecon-compress</code> tool compresses or decompresses GFXReconstruct capture files. It can also be used to change the compression format used in a capture file.</p>
<pre class="text"><code>gfxrecon-compress - A tool to compress/decompress GFXReconstruct capture files.

Usage:
  gfxrecon-compress [-h | --help] [--version] &lt;input_file&gt; &lt;output_file&gt; &lt;compression_format&gt;

Required arguments:
  &lt;input_file&gt;    Path to the input file to process.
  &lt;output_file&gt;   Path to the output file to generate.
  &lt;compression_format&gt;  Compression format to apply to the output file.
                        Options are:
                          LZ4  - Use LZ4 compression.
                          ZLIB - Use zlib compression.
                          ZSTD - Use Zstandard compression.
                          NONE - Remove compression.

Optional arguments:
  -h              Print usage information and exit (same as --help).
  --version       Print version information and exit.
</code></pre>
<h3 id="shader-extraction">Shader Extraction</h3>
<p>The <code>gfxrecon-extract</code> tool extracts all shaders in a GFXReconstruct capture file. The extracted shaders are placed into a specified directory.</p>
<pre class="text"><code>gfxrecon-extract - Extract shaders from a GFXReconstruct capture file.

Usage:
  gfxrecon-extract [-h | --help] [--version] [--dir &lt;dir&gt;] &lt;file&gt;

Optional arguments:
  -h          Print usage information and exit (same as --help).
  --version   Print version information and exit.
  --dir &lt;dir&gt; Place extracted shaders into directory &lt;dir&gt;. Otherwise
              use &lt;file&gt;.shaders in working directory. Create directory
              if necessary. Each shader is placed in individual file
              named sh&lt;handle_id&gt; where handle_id is handle id of the
              CreateShaderModule call. See gfxrecon-replay --replace-shaders.
Required arguments:
  &lt;file&gt;      The GFXReconstruct capture file to be processed.
</code></pre>
<h3 id="trimmed-file-optimization">Trimmed File Optimization</h3>
<p>The <code>gfxrecon-optimize</code> tool removes unused buffer and image initialization data from trimmed capture files.</p>
<p>For trimmed capture files, a snapshot of the Vulkan API state is written at the start of the file. This state snapshot includes the data for all buffers and images that were live at the time that capture started. Some of the buffer and image objects captured in the state snapshot may go unreferenced by the captured frames and their data can be removed from the capture file. The <code>gfxrecon-optimize</code> tool will process a trimmed file to identify buffer and image objects that were initialized in the state snapshot, but were not used by any of the captured frames, and generate a new capture file that omits the data for these unused buffer and image objects.</p>
<pre class="text"><code>gfxrecon-optimize - Remove unused resource initialization data from trimmed
                    GFXReconstruct capture files.

Usage:
  gfxrecon-optimize [-h | --help] [--version] &lt;input-file&gt; &lt;output-file&gt;

Required arguments:
  &lt;input-file&gt;          The trimmed GFXReconstruct capture file to be
                        processed.
  &lt;output-file&gt;         The name of the new GFXReconstruct capture file to be
                        created.

Optional arguments:
  -h                    Print usage information and exit (same as --help).
  --version             Print version information and exit.
</code></pre>
<h3 id="json-lines-conversion">JSON Lines Conversion</h3>
<p>The <code>gfxrecon-convert</code> tool converts a capture file into a series of JSON documents, one per line following the <a href="https://jsonlines.org/" TARGET="_blank">JSON Lines standard</a>. The JSON document on each line is designed to be parsed by tools such as simple Python scripts as well as being useful for inspection by eye after pretty printing, for example by piping through a command-line tool such as <a href="https://stedolan.github.io/jq/" TARGET="_blank"><code>jq</code></a>. For these post-processing use cases, <code>gfxrecon-convert</code> can be used to stream from binary captures directly, without having to save the intermediate JSON files to storage. Because each JSON object is on its own line, line oriented tools such as grep, sed, head, and split can be applied ahead of JSON-aware ones which are heavier-weight to reduce their workload on large captures.</p>
<p>The file begins with a header object containing some metadata, followed by a series of objects representing the sequence of Vulkan calls stored in the capture. More details of the file format can be found in the tool's <a href="convert.html">README</a>.</p>
<pre class="text"><code>gfxrecon-convert - A tool to convert GFXReconstruct capture files to text.

Usage:
  gfxrecon-convert [-h | --help] [--version] &lt;file&gt;

Required arguments:
  &lt;file&gt;        Path to the GFXReconstruct capture file to be converted
                to text.

Optional arguments:
  -h                    Print usage information and exit (same as --help).
  --version             Print version information and exit.
  --output file         &#39;stdout&#39; or a path to a file to write JSON output
                        to. Default is the input filepath with &quot;gfxr&quot; replaced
                        by &quot;jsonl&quot;.
  --no-debug-popup      Disable the &#39;Abort, Retry, Ignore&#39; message box
                        displayed when abort() is called (Windows debug only).
</code></pre>
<h3 id="command-launcher">Command Launcher</h3>
<p>The <code>gfxrecon.py</code> tool is a utility that can be used to launch all of the GFXReconstruct commands.</p>
<pre class="text"><code>usage: gfxrecon.py [-h] command ...

GFXReconstruct utility launcher.

positional arguments:
  command     Command to execute. Valid options are [capture, compress, convert,
              extract, info, optimize, replay]
  args        Command-specific argument list. Specify -h after command name for
              command help.

optional arguments:
  -h, --help  show this help message and exit
</code></pre>
<p>The <code>gfxrecon.py</code> tool is a Python3 script. In order to use it, a Python3 interpreter must first be installed. Once Python3 is installed, you should be able to invoke <code>gfxrecon.py</code> by simply typing:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1"><span class="ex">gfxrecon.py</span> capture -o vkcube.gfxr vkcube</a></code></pre></div>
<p>On Windows, after installing Python3, be sure to associate the <code>.py</code> file extension with the Python3 interpreter before you run the script.</p>
<h3 id="options-common-to-all-tools">Options Common To all Tools</h3>
<p>If the environment variable <code>GFXRECON_NO_DEBUG_POPUP</code> has any non-zero number or non-empty, non-numeric string value when running any of of the file processing tools, the tool will attempt to disable the 'Abort, Retry, Ignore' message box displayed when <code>assert()</code> fails on Windows in a Debug build. This behavior is slightly different than <code>--no-debug-popup</code> in that the message box is disabled before any other variable initialization. This is probably most useful in headless or "Continuous Integration" builds when an on-screen message box that can't be automatically dismissed may hang scripts or cause directories to be locked. (Note that "FALSE" and "no", as examples, are non-empty, non-numeric string values and will be interpreted as enabling the option.)</p>
</article>
</body>
</html>
